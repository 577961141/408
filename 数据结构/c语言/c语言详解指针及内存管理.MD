# C语言详解指针地址及内存管理

## 简介

指针是什么？是一个值，这个值代表一个内存地址。

字符`*`表示指针，通常在类型关键字的后面，表示指针指向的是什么类型的值。比如，`char*` 表示一个指向字符的指针，`float*`表示一个指向`float`类型的值指针。

```c
int *intPtr;
```
上面示例声明了一个变量`intPtr`，它是一个指针，指向的内存地址存放的一个整数。

***指针变量就是普通的变量，只不过它的值是内存地址而已***。

一个指针的指向的可能还是指针，这时就要用两个星号`**`表示.

```c
int** foo;
```
上面示例表示变量`foo`是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。

## * 运算符

`*`这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。

```C
void increment(int* p) {
    *p = *p+1;
}
```

上面示例中，函数increment()的参数是一个整数指针p。函数体里面，*p就表示指针p所指向的那个值。对*p赋值，就表示改变指针所指向的那个地址里面的值。

上面函数的作用是将参数值加1。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。

## &运算符

`&`运算符用来取出一个变量所在的内存地址。
```c
int x = 1;
priintf("%p", &x);
```

上面示例中，x是一个整数变量，&x就是x的值所在的内存地址。printf()的%p是内存地址的占位符，可以打印出内存地址。

上一个小节中，参数变量加1的函数，可以像下面这样使用。

```c
void increment(int *p) {
    *p = *p+1;
}

int x = 1;
increment(&x);
printf("%d\n", x); // 2 
```

上面示例中，调用increment()函数以后，变量x的值就增加了1，原因就在于传入函数的是变量x的地址&x。

&运算符与*运算符互为逆运算，下面的表达式总是成立。

```c
int i = 5;

if (i == *(&i)) // 正确
```

## 指针变量的初始化

声明指针变量之后。编译器会为指针变量本身分配一个内存空间，但是这个内存空间的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的内存地址，因为哪个地址是随机地址，可能会造成很严重的后果
```c
int* p;
*p = 1; // error
```
上面的代码是错误的，因为p指向的那个地址是随机的，向这个随机地址吸入1，会导致意想不到的结果。

正确的做法是指针变量声明后，必须让他指向分配好的地址，然后进行读写，这叫做指针变量的初始化。

```c
int *p;
int i;

p = &i;
*p = 13;
```

为了防止读写为初始化的指针变量，可以养成习惯，将未初始化的指针变量设置为NULL;

```C
int *p = NULL;
```

NULL在c语言中是一个常量，表示地址为0的内存空间，这个地址是无法使用的，读写该地址会报错。

## 疑问

1. 下面两端代码中有什么不一样？

代码1
```c
viod main() {
    int* p;
    int i;
    
    p = &i;
    *p = 5;
}
```

代码2
```c
void main() {
    int p;
    
    p = 0;
    increase(&p);
}

void increase(int* p) {
    *p = *p+1;
}
```

理解：代码1是对地址进行赋值。代码2是对值进行操作