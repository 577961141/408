# C语言学习

## 一、C语言简介

### C语言编译

C语言是一种编译语言，源码都是文本文件，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。编译器代码从文本翻译成二进制指令过程，就被称为编译过程，又称为“编译时”。跟运行时相区分

### Hello Word示例

一般C文件都是一`.c`结尾。我们创建一个`hellp.c`,它就是一个普通的文本文件

```
#include <stdio.h>

int main(void) {
    printf("Hello World\n")
    return 0
}
```

然后执行编译命令

```shell
$ gcc hello.c
```

在该文件夹下会生成一个可执行的二进制文件`a.exe`(不指定生成名就是这个名字)

然后再执行如下命令，就可以看到在屏幕上输出`Hello World`

```shell
$.\a.exe   
```

GCC 的 参数（这里只介绍两个）

指定生成文件的名称：`gcc -o hello hello.c`

按照指定标准来编译：`gcc -std=c99 hello.c`

## 二、C语言基本语法

### 语句

语句必须使用分号结尾。如下所示

```c
int x = 1;
```

一条语句也可以写成多行，如下

```c
int x;
	x
    =
    1;
```

### 表达式

C语言的各种计算，是通过表达式来完成。表达式是一个计算式，用来获取值。如

```c
1+2
```

表达式与语句的区分：

- 语句可以包含表达式，但是表达式本身不构成语句
- 表达式都有值返回，语句不一定有。

### 语句块

C语言允许多个语句使用一对大括号`{}`,组成一个块，也称为复合语句。在语法上，语句块可以视为多个语句组成的一个复合语句

```shell
{
	int x;
	x = 1;
}
```

### 空格&注释

懂的都懂

### `printf()`

`printf()`函数是在标准库的头文件`stdio.h`定义的

有如下几种

```c
// 直接输出
printf("Hello world");

// 换行
printf("Hello World\n");

// 占位符（占位符有很多，可以自行百度）
printf("There are %i apples\n", 3); // 输出"There are 3 apples"

// 输出格式-先定宽度
printf("%5d\n", 123); // "  123" (如果空格要在后面写成"%-5d")
printf("%12f\n", 123.45); // 输出 " 123.450000"  %12f 表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以会在头部添加2个空格

// 输出格式-总是显示正负号
printf("%+d\n", 12); // 输出 +12
printf("%+d\n", -12); // 输出-12

// 输出格式-限定小数位数
printf("%6.2f\n", 0.5); // 总长度为6，小数有2位
printf("%*.*f\n", 6, 2, 0.5); // 与上一条等同
    
 // 输出格式-输出部分字符串   
printf("%.5s\n", "hello world"); // 输出hello
 
```

### 标准库，头文件

有些功能不用自己编写，直接引入使用就可以了。

## 三、变量

变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。

### 变量名

命名规范：

- 只能是数字、字母、下划线组成
- 不能以数字开头
- 不能超过63个字符

变量名区分大小写，`start`、`Start`是不同的

另外一些保留字，关键字是不允许作为变量的。

### 变量声明

每个变量都有自己的类型（type）。声明变量时，必须吧变量的类型告诉编译器

```c
int height;
```

如果几个变量具有相同的类型，可以在同一行声明

```c
int heigt, width;
```

### 变量的赋值

C语言在声明变量时，就为他分配内存空间，但是不会清除内存中原来的值。这导致声明变量后，变量会是一个随机的值。所以变量一定要赋值以后才能使用（按照下面的方式就会报错）

```c
#include <stdio.h>

int main(viod) {
    int a;
    printf(a) // 报错，应该改成 printf("%i/n", a)，这样就会输出随机的数
}

```

赋值方式：

```c
// 方式一
int num;
num = 1;

// 方式二
int num = 1;

// 方式三
int x=1, y=2;

// 方式四
int x,y;
x = 1;
y = (x = 2*x);

//方式五
int x, y, z, m, n;
x = y = z = m = n = 3;
```

### 变量作用域

作用域(scope)指的是变量生效的范围。C语言的变量作用域主要有两种：文件作用域和块作用域。

文件作用域指的是，从源码文件顶层声明的变量，从声明的位置到文件结束都有效，如下

```c
int x = 1;

int main(void) {
    printf("%i\n", x);
}
```

块作用域指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域声明的变量，都只在当前代码块有效。代码块外部不可见。

```c
int a = 12;

if (a == 12) {
    int b = 99;
    printf("%d\n %d", a, b); // 12 99
}

printf("%d\n", a); // 12
printf("%d\n", n); // 出错
```

代码块是可以嵌套的。规则是：内层代码块可以使用外层声明的变量，但外层不能使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量

```c
{
    int i = 10;
    
    {
        int i = 20;
        printf("%d\n", i); // 20
    }
    
    printf("%d\n", i); // 10
}
```

上面示例中，内层和外层都有一个变量 i ，每个作用域都会优先使用当前作用域声明的 i 。

注`for`循环也是一个块作用域。循环变量只对循环内部可见，外部是不可见的。

```c
for (int i = 0; i < 10; i++)
  printf("%d\n", i);
printf("%d\n", i); // 出错
```

### 数据类型

C基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于他们构建的

#### 字符类型

字符类型指的是单个字符，类型声明使用`char`关键字

```c
char C = 'B'
```

- 字符常量必须放在单引号里面

- 字符类型使用一个字节存储（8位）。

- 只要在字符类型的范围内，整数与字符是可以互换的，都可以赋值给字符类型的变量。

  ```c
  char c = 66;
  // 等同于
  char c = 'B'
  ```

- 两个字符类型的变量是可以进行数学运算的

  ```c
  char a = 'B'; // 等同于66
  char b = 'C'; // 等同于77
  
  printf("%d\n", a+b); // 输出133
  ```

- 单引号本身也是一个字符，如果要标识这个字符常量，必须使用反斜杠转义

  ```
  char t = '\'';
  ```

  这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。

  - \a ：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。

  - \b ：退格键，光标回退一个字符，但不删除字符。

  - \f ：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于 \v 。

  - \n ：换行符。

  - \r ：回车符，光标移到同一行的开头。

  - \t ：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。

  - \v ：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。

  - \0 ：null 字符，代表没有内容。注意，这个值不等于数字0。

  转义写法还能使用八进制和十六进制标识一个字符。

  - `\nn`:字符的八进制写法，`nn`为八进制

  - `\xnn`:字符的十六进制写法，`nn`为十六进制

    ```c
    char x = 'B';
    char x = 66;
    char x = '\102'; // 八进制
    char x = '\x42'; // 十六进制
    ```

    上面四种写法是等价的

## 四、整数类型

声明格式如下：

```c
int a;
```

不同计算机的 int 类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个 int 类型的值(c就是)，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。

- 16位：-32,768 到 32,767。

- 32位：-2,147,483,648 到 2,147,483,647。

- 64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。

**signed**，**unsigned**

signed不区分正负号，unsigned 区分正负号（只要正号）。但是这两种范围不一样了。举例子（只是例子，并不代表数据范围就这么大）。比如，16位的 signed int 最大值为32,767，而 unsigned int 的最大值增大到了65,535

`signed int`等同`int`可以省略。所以也可以写成下面这样

```c
signed int a;
//等同于
int a;
```

`unsigned int`里面`int`可以省略。所以也可以写成下面这样

```c
unsigned int a;
// 等同于
unsigned a;
```

char也可以区分`signed`和`unsigned`。

```c
signed char c; // 范围-127到128
unsigned char c; // 范围0到255
```

注意，C语言规定`char`类型默认是否带有正负号，由当前系统决定。也就是说，`char`不等同于`signed char`,它有可能是`signed char`,也有可能是`unsigned char`.这一点与`int`不同，`int`就是等同于`signed int`

### 整数的子类型

- `short int`(简单简写为`short`)：占用空间不多于`int`,一般2个字节（整数范围为-32768～32767)

- `long int` （简写为 long ）：占用空间不少于 int ，至少为4个字节。

- `long long int`（简写为`long long`）:占用空间多于`long`,至少为`8`个字节

  ```c
  short int a;
  long int b;
  long long int c;
  ```

  默认情况下， short 、 long 、 long long 都是带符号的（signed），即 signed 关键字省略了。它们

  也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。

  ```c
  unsigned short int a;
  ```

  

  C 语言允许省略 int ，所以变量声明语句也可以写成下面这样。

  ```c
  short a;
  unsigned short a;
  ```

  不同的计算机，数据类型的字节长是不一样的，确实需要32位整数时，应该使用`long`类型而不是`int`类型，可以确保不少于4个字节；确实需要64位整数时，应该使用`long long`类型，可以确保不少于8个字节。另一方面为了节省空间，只需要16位整数时，应使用`short`类型；需要8位整数时，应该使用`char`类型

### 整数类型的极限值

可以在C语言的头文件`limits.h`看到，如`SCHAR_MIN`代表signed char类型的最小值为-128。SCHAR_MAX 代表 signed char 类型的最大值 127，其余的自行查找 

### 整数的进制

C语言默认十进制

八进制,以0作为前缀

```c
int a = 012;
```

十六进制，以`0x`为前缀

```c
int a = 0x12;
```

二进制，以`0b`为前缀

```c
int a = 0b101010;
```

所有的整数都是以二进制的形式存储，跟书写方式无关。不同的进制可以混合使用，如`10+015+0x20`

进制的相关占位符如下：

- %d：十进制整数
- %o：八进制整数
- %x：十六进制整数
- %#o：以0开头的八进制
- %#x：以`0x`开头的八进制
- %#X：以`0X`开头的八进制

例子如下：

```c
#include <stdio.h>

int main(void) {
    int a = 100;
    printf("%d\n", a); // 100
    printf("%o\n", a); // 144
    printf("%#o\n", a); // 0144
    printf("%x\n", a); // 64
    printf("%#x\n", a); // 0x64
    printf("%#X\n", a); // 0X64
}
```

### 浮点数类型

所谓“浮点数”就是使用`m*b^e`的形式，存储一个数值，`m`是小数部分，`b`是基数部分（通常是2），`e`是指数部分。这种形式是精度和数值范围的一种结合，可以标识非常大或者非常小的数

C语言中浮点数声明如下

```c
float c = 10.05;
```

`float`类型占用4个字节（32）位，其中8位存放指数的符号和值，剩下24位存放小数的符号和值。

`float`类型至少能提供（十进制）6位有效数字，指数部分的范围为（十进制）`-37`到`37`,即数值取值范围为`10^-37`到`10^37`

> 当32位浮点数提供的精度或者数值范围不够时，有如下两个更大的浮点数类型。
>
> - double：占8个字节（64位），至少提供13位有效数字
> - long double：通常16个字节

注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面 0.1 + 0.2并不等于 0.3 ，而是有一个很小的误差。

C 语言允许使用科学计数法表示浮点数，使用字母 e 来分隔小数部分和指数部分。

```c
double x = 123.456e+3; // 123.456*10^3
// 等同于
double x = 123.456e3;
```

另外，科学计数法的小数部分如果是 0.x 或 x.0 的形式，那么 0 可以省略。

```
0.3E6
// 等同于
.3E6

3.0E6
// 等同于
3.E6
```

### 布尔类型

- C语言并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非0值表示真

  ```c
  int x = 1;
  if (x) {
    printf("x is true!\n");
  }
  ```

- C99标准添加了类型`_Bool`,表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用`0`表示伪，`1`表示真，如下

  ```c
  #include <stdio.h>
  
  int main(void) {
      _Bool isNormal;
  
      isNormal = 1;
      if (isNormal) {
          printf("yes\n");
      }
  }
  ```

- 头文件`stdbool.h`定义了另一个类型别名`bool`,并定义了`true`代表`1`、`false`代表`0`.只要加载这个头文件，就可以使用这几个关键字

  ```c
  #include <stdbool.h>
  bool flag = false;
  ```

### 字面量类型

字面量指的是代码里面直接出现的值

```c
int x = 123；
```

上面代码中`x`是变量，`123`就是字面量

编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型。（如编译器把十进制整数字面量（比如 123 ）会被编译器指定为 int 类型）

#### 字面量后缀

如果要把一个字面的类型指定为`long`可以像如下

```c
int x = 123L;
```

常用的字面量后缀有如下：

- `f`和`F`:`float`类型
- `l`和`L`：对于整数时`long int`类型，对于小数是`long double`类型
- `ll`和`LL`：`LongLong`类型，比如`3LL`
- `u`和`U`：表示`unsigned int`,如`15U`、`0377u`

u 还可以与其他整数后缀结合，放在前面或后面都可以，比如 10UL 、 10ULL 和 10LLU 都是合法的。

### 溢出

超过了存放数值的范围，就需要更多的二进制为存储，就会发生溢出。大于最大值，叫做向上溢出，反之向下溢出

一般来说，编译器不会对溢出报错的，会正常执行代码，但是会把高位舍弃，留下低位。如下

```c
unsigned char x = 255;
x = x + 1;
printf("%d\n", x); // 0
```

为什么是0？因为x 是 unsign char 类型，最大值是255 （二进制 11111111 ），加 1 后就发生了溢出， 256 （二进制 100000000 ）的最高位 1 被丢弃，剩下的值就是 0 。

另一个例子

```c

int main(void) {
    unsigned int ui = UINT_MAX;  // 4,294,967,295
    ui++;
    printf("ui = %u\n", ui); // 0
    ui--;
    printf("ui = %u\n", ui); // 4,294,967,295
}
```

防止溢出的最好方法，就是将运算结果与极限值相比较

```c
if (ui > UINT_MAX - sum) too_big();
else sum = sum +ui
```

另一种错误的写法。

```c
unsigned int i = 5;
unsigned int j = 7;
if (i - j < 0) // 错误
  printf("negative\n");
else
  printf("positive\n");
```

### sizeof运算符运算符

`sizeof `是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。

```c
int x = sizeof(int); // 参数为数据类型（显示4或者8字节）

int i;
sizeof(i); // 参数为变量（显示4或者8字节）

sizeof(3.14); // 参数为数值（显示8字节，浮点数的字面量一律存储为double类型）
```

`sizeof`运算符的返回值，C语言只规定是无符号的整数。在不同的系统中类型有可能是`unsigned int`,也有可能是`unsigned log`,甚至是`unsigned long long`,对应的`printf()`占位符分别是`%u`、`%lu`和`%llu`.这样不利于程序的可移植性。

所以C语言规定了一个类型来表示。类型为`size_t`，用来统一表示`sizeof`返回值的类型。对应当前系统的 sizeof 的返回值类型，可能是` unsigned int` ，也可能是` unsigned long`.

还提供了一个常量`SIZE_MAX`，表示`size_t`可以标识的最大整数。

`printf()`有专门的占位符`%zd`和`%zu`,用来处理`size_t`类型的值。（如果当前系统不支持`%zd`和`%zu`）,可以使用`%u`或者`%lu`来代替。

### 类型自动转换

某些情况下，C语言会自动转换某个值的类型。

### 赋值运算符

（1）浮点数赋值给整数变量

```c
int x = 3.14; // 不进行四舍五入，去掉小数。
```

（2）整数赋值给浮点数变量

```c
float x = 2*12; // 结果为24.0
```

（3）窄类型赋值给宽类型

```c
char x = 10;
int i = x+y;
```

变量 x 的类型是 char ，由于赋值给 int 类型，所以会自动提升为 int 。

（4）宽类型赋值给窄类型

字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。

```c
int i = 321;
char ch = i; // ch的值是65（321-256）
```

上面例子中，变量 ch 是 char 类型，宽度是8个二进制位。变量 i 是 int 类型，将 i 赋值给 ch ，后者只能容纳 i （二进制形式为 101000001 ，共9位）的后八位，前面多出来的二进制位被丢弃，保留后八位就变成了 01000001 （十进制的65，相当于字符 A ）。

### 混合类型的运算

（1）整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。

```c
3 + 1.2  // 4.2
```

（2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如 float 转为double ， double 转为 long double 。

（3）不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如 short 转为 int ，int 转为 long 等，有时还会将带符号的类型 signed 转为无符号 unsigned 。

下面例子的执行结果，会出人意外：

```c
int a = -5;
if (a < sizeof(int)) {
    do_something();
}
```

上面示例中，变量 a 是带符号整数， sizeof(int) 是 size_t 类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以 a 会自动转成无符号整数 4294967291 （转换规则是 -5 加上无符号整数的最大值，再加1），导致比较失败， do_something() 不会执行。

### 整数类型的运算

两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于 int 的类型，运算结果会自动提升为 int 。

```c
unsigned char a = 66;

if ((-a) < 0) printf("negative\n");
else printf("positive\n")
```

上面示例中，变量 a 是 unsigned char 类型，这个类型不可能小于0，但是 -a 不是 unsigned char 类型，会自动转为 int 类型，导致上面的代码输出 negative。

再看下面的例子。

```c
unsigned char a = 1;
unsigned char b = 255;
unsigned char c = 255;

if ((a-5) <0) do_something(); // a-5自动转换为int类型
if ((b + c) > 300) do_something(); // b+c自动转换为int类型
```

### 函数

函数的参数和返回值，会自动转换成函数定义里面指定的类型。

```c
int dosuff(int, unsigned char);

char m = 42;
unsigned short n = 43;
long long int c = dosuff(m, n)
```

上面示例中，参数变量 m 和 n 不管原来的类型是什么，都会转成函数 dostuff() 定义的参数类型。

下面是返回值自动转换类型的例子。

```c
char func(void) {
    int a = 42;
    return a;
}
```

上面示例中，函数内部的变量 a 是 int 类型，但是返回的值是 char 类型，因为函数定义中返回的是这个类型。

### 类型的显示转换

只要在一个值或变量的前面，使用圆括号指定类型`（type）`，就可以将这个值或变量转为指定的类型。这叫做“类型指定”（casting）。

变量

```c
(unsigned char) ch
```

值

```c
long int y = (long int) 10 + 12;
```

### 可移植类型

C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节

程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件 stdint.h 创造了一些新的类型别名。

（1）精确宽度类型，保证某个整数类型的宽度是确定的。

- int8_t ：8位有符号整数。
- int16_t ：16位有符号整数。
- int32_t ：32位有符号整数。
- int64_t ：64位有符号整数。
- uint8_t ：8位无符号整数。
- uint16_t ：16位无符号整数。
- uint32_t ：32位无符号整数。
- uint64_t ：64位无符号整数

上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果 int 类型为32位， int32_t 就会指向 int ；如果 long 类型为32位， int32_t 则会指向 long 。

（2）最小宽度类型（minimum width type），保证某个整数类型的最小长度。（自己查）

（3）最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型（自己查）

计算机会对符合自己位数的计算快。如你的计算机是32位的，那么肯定对32位的计算快。

（4）可以保存指针的整数类型

- `intptr_t`:可以存储指针（内存地址）的有符号整数类型
- `uintptr_t`:可以存储指针的无符号整数类型

（5）最大宽度整数类型，用于存放最大的整数。

- `intmax_t`:可以存储任何有效的有符号整数的类型。
- `uintmax_t`: 可以存放任何有效的无符号整数的类型

上面的这两个类型的宽度比 long long 和 unsigned long 更大

## 五、运算符

1. 在C语言中，整数的除法是整除，只返回整数部分，丢弃小数部分。

   ```c
   float x = 6 / 4;
   printf("%f\n", x); // 输出 1.000000
   ```

​		如果希望得到浮点数，连个运算数必须至少一个浮点数，这时C语言才会进行浮点数除法。

```c
float x = 6.0 / 4;
printf("%f\n", x); // 输出1.500000
```

2. 负数的求模，正负是由第一个参数的正负决定的

   ```c
   11 % 5; // 1
   -11 % -5; // 1
   ```

3. 下面的例子中会变成`0`或`1`与变量`k`比较

   ```c
   i < j && j < k
   ```


### 位运算符

（1）取反运算符 ～

用来将每一个二进制位变成相反值，即 0 变成 1 ， 1 变成 0 。

```c
// 返回 01101100
~ 10010011
```

注意，`~`运算符不会改变变量的值，只会返回一个新的值。（一元运算符）

（2）与运算符 &

当两个二进制位都为 1 ，就返回1 ，否则返回 0 。

```c
// 返回 00010001
10010011 & 00111101
```

与运算符`&`可以赋值运算符`=`结合，简写成`&=`

```c
int val = 3;
val = val & 0377;

// 简写成
val &= 0377；
```

（3）或运算符 |

两个二进制位只要有一个为 1 （包含两个都为 1 的情况），就返回 1 ，否则返回 0 。

```c
// 返回 10111111
10010011 | 00111101
```

或运算符 | 可以与赋值运算符 = 结合，简写成 |= 。(参考&=)

（4）异或运算符`^`

两个二进制位有且仅有一个为`1`,就返回`1`,否则返回`0`

```c
// 返回 10101110
10010011 ^ 00111101
```

异或运算符 ^ 可以与赋值运算符 = 结合，简写成 ^= 。

（5）左移运算符`<<`

左移运算符`<<`将左侧运算数的每一位，向左移动指定的位数，尾部空出来的用0填充。

```c
// 1000101000
10001010 << 2
```

左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）

左移运算符 << 可以与赋值运算符 = 结合，简写成 <<= 。

（6）右移运算符

参考左移，与之相反

（7）逗号运算符

逗号运算符将多个表达式写在一起，从左往右一次运行每个表达式。

```c
x = 10, y = 20;
```

上面示例中，有两个表达式（ x = 10 和 y = 20 ），逗号使得它们可以放在同一条语句里面。逗号运算符返回最后一个表达式的值，作为整个语句的值。

```c
int x;
x = 1, 2, 3; //逗号运算符的优先级略低于复制运算符
```

（8）优先级

懂的都懂

## 六、数组

声明数组格式如下：

```c
int scores[100];
```

- 要声明数组的类型，数组的个数

- 如果引用数组不存在的成员（越界访问数组），并不会报错

  ```c
  int scores[100];
  
  scores[100] = 51;
  ```

  上面示例中，数组`scores`只有100个成员，因此`scores[100]`这个位置是不存在。但是，引用这个位置并不会报错，会正常运行，使得紧跟scores后面的那块内存区域被赋值，而实际上是其他变量的区域，这样会不知不觉的改变其他变量的值。这样容易引发错误，而且难以发现。

- 数组也可以在声明时，使用大括号，同时对每一个成员赋值。

  ```c
  int a[5] = {22, 37, 3490, 18, 95}
  ```

  注意，使用大括号赋值时，必须声明是赋值，否则编译时会报错。

  ```c
  int a[5];
  a = {22, 37, 3490, 18, 95};// 报错
  ```

  报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。

  ```c
  int a[5] = {1, 2, 3, 4, 5};
  a = {22, 37, 3490, 18, 95}; // 报错
  ```

  使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。

  如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为 0 。

  如果要将整个数组的每个成员都设置为0，最简单的写法如下

  ```c
  int a[int] = {0};
  ```

  数组初始化时，可以指定为哪些位置的成员赋值

  ```c
  int a[5] = {[2] = 29, [9] = 7, [14] = 48};
  ```

  上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。

  指定位置的赋值可以不按照顺序。

  指定位置的赋值与顺序赋值，可以结合使用。

  ```c
  int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
  ```

  上面示例中，0号、5号、6号、10号、11号被赋值。

  C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。

  ```c
  int a[] = {22, 37, 3490};
  // 等同
  int a[3] = {22, 37, 3490};
  ```

  省略成员数量时，如果采用指定位置赋值，那么数组的长度将是最大的指定位置再加1。

  ```c
  int a[] = {[2] = 6, [9] = 12};
  ```

​		上面的示例中，数组`a`的最大指定位置是`9`,所以数组的长度为`10`.

### 数组的长度

`sizeof`运算符会返回整个数组的字节长度

```c
int a[] = {22, 37, 3490};
int arrLen = sizeof(a); // 12
```

上面示例中， sizeof 返回数组 a 的字节长度是 12

> 数组的成员数量 = sizeof(a) / sizeof(a[0])

### 多维数组

声明

```c
int board[10][10]
```

也可以有三维的。

大括号表示法

```c
int a[2][5] = {
    {0, 1, 2, 3, 4},
    {5, 6, 7, 8, 9}
}
```

上面示例中， a 是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。这种写法不用为每个成员都赋值，缺少的成员会自动设置为 0

另一种赋值方式

```c
int a[2][2] = {[0][0] = 1, [1][1] = 2};
```

不管数组多少维度，在内存里面都是线性存储，`a[0][0]`的后面就是`a[0][1]`。所以，多维数组也可以使用大括号赋值，下面语句与上面的赋值语句完全相同。

```c
int a[2][2] = {1, 0, 0, 2};
```

### 变长数组

数组在声明的时候，数组的长度除了使用常量，也可以是变量，这叫变长函数，

```c
int n = x+y;
int arr[n]; // n只有在运行的时候才知道是多少，这样程序员就不用在开发的时候给到值
```

变长数组也可以用于多维数组

```c
int a[m][n]
```

### 数组的地址

数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。

```c
#include <stdio.h>

int main(void) {
    int a[5] = {11, 22, 33, 44, 55};
    int* p;

    p = &a[0];

    printf("%d\n", *p); // Prints "11";
}
```

上面示例中， &a[0] 就是数组 a 的首个成员 11 的内存地址，也是整个数组的起始地址。反过来，从这个地址（ *p ），可以获得首个成员的值 11.

由于数组的起始地址是常用操作， &array[0] 的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（ array[0] ）的指针。

```c
int a[5] = {11, 22, 33, 44, 55};

int* p = &a[0];
//等同
int* p = a;
```

函数接受数组作为参数，函数原型可以写成下面这样。

```c
int sum(int arr[], int len);
int sum(int* arr, int len);
```

上面的示例中，传入一个整数，与传入一个整数指针是同一回事，数组符号`[]`与指针符号`*`是可以互换的。下一个例子是通过数组指针对成员的求和。

```c
int sum(int* arr, int len) {
    int i;
    int total = 0;
    
    for (i = 0; i < len; i++) {
        total += arr[i];
    }
    return total;
}
```

`*`和`&`运算符也可以用于多维数组

```c
int a[4][2];

// 取出 a[0][0]的值
*(a[0]);
// 等同于
**a;

```

上面示例中，由于`a[0]`本身就是一个指针，指向第二维数组的第一个成员`a[0][0]`。所以，`*a[0]`取出的是`a[0][0]`的值。至于`**a`,就是对`a`进行两次`*`运算，第一次取出的是`a[0]`,第二次取出的是`a[0][0]`.同理，二维数组的`&a[0][0]`等同于`*a`.

注意，数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个内存地址与数组名是绑定的，不可更改，下面的代码会报错。

```c
int ints[100];
ints = NULL; //报错
```

重新为数组名赋值，改变原来的内存地址，就会报错。

不能将数组名复制给另外一个数组名。

```c
int a[5] = {1, 2, 3, 4, 5};

// 写法一
int b[5] = a; // 报错

// 写法二
int b[5];
b = a; // 报错
```

### 数组指针的加减法

C语言里面，数组名可以在进行加减法计算，等同于在数组成员之间前后移动，即从一个成员的内存移动到另一个成员的内存地址。如```a+1```返回下一个成员的地址，```a-1```返回上一个成员的地址。

```c
int a[5] = {11, 22, 33, 44, 55};

for (int i = 0; i < 5; i++) {
    printf("%d\n", *(a + i));
}
```

由于数组名与指针是等价的，所以下面的等式总是成立的
```c
a[b] == *(a + b);
```

如果指针变量`p`指向数组的一个成员，那么`p++`就相当于指向下一个成员，这种方法常用来遍历数组

```c
int a[] = {11, 22, 33, 44, 55, 999};

int* p = a;

while (*p != 999) {
    printf("%d\n", *p);
    p++;
} 
```

注意：数组名执行地址是不能变的，所以上例子中，不能直接对a进行自增，即`a++`的写法是错误的，必须将`a`的地址赋值给指针变量`p`,然后对p进行自增

遍历数组一般是通过数组的长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现。

```c
int sum(int *start, int *end) {
    int total = 0;
    
    while (start < end) {
        total += *start;
        strart++;
    }
    
    return total;
}

int arr [5] = {20, 10, 5, 39, 4};
printf("%i\n", sum(arr, arr+5))
```

上面示例中， arr 是数组的起始地址， arr + 5 是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。

反过来，通过数组的减法，就可以知道两个地址之间有多少成员，请看下面的例子，自己实现一个计算数组长度的函数。

```c
int arr[5] = {20, 10, 5, 39, 88};
int* p = arr;

while (*p != 88) 
    p++;

printf("%i\n", p - arr);
```

上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员。

对于多维数组，数组指针的加减法对于不同维度，含义是不一样的

```c
int arr[4][2];

arr+1; // 指向arr[1]

arr[0]+1; // 指向arr[0][1]
```

上面示例中， arr 是一个二维数组， arr + 1 是将指针移动到第一维数组的下一个成员，即 arr[1] 。由于每个第一维的成员，本身都包含另一个数组，即 arr[0] 是一个指向第二维数组的指针，所以arr[0] + 1 的含义是将指针移动到第二维数组的下一个成员，即 `arr[0][1]` 。

同一个数组的两个成员相减时，返回他们之间的距离。

```c
int* p = &a[5];
int* q = &a[1];

printf("%d\n", p - q); // 4(两个地址相减)
```

### 数组的复制

由于数组名是指针，所以复制数组不能简单地复制数组名。

```c
int* a;
int b[3] = {1, 2, 3};

a = b;

b[0] = 5;

printf("%d\n", a[0]); // 输出5，而不是1，因为复制的是地址，而不是内存
```

上面的写法，结果不是将数组`b`复制给数组`a`,而是让`a`和`b`指向统一数组

复制数组最简单的方法，还是使用循环，将元素逐个进行复制。

```c
for (i = 0; i < N; i++) {
    a[i] = b[i];
}
```

另一种方法是使用 memcpy() 函数（定义在头文件 string.h ），直接把数组所在的那一段内存，再复制一份。

```c
int main(void) {
    int a[3];
    int b[3] = {1, 2, 3};

    memcpy(a, b, sizeof(b));

    b[0] = 5;

    printf("%d\n", a[0]); // 输出1 而不是5。复制的是b的内存，不是b的地址
}
```

这种方法要比循环快

### 作为函数的参数

#### 声明参数数组

数组作为函数的参数，一般会传入数组名和数组的长度。

```c
int sum_array(int a[], int n) {
    // ...
}

int a[] = {3, 5, 7, 3}
int sum  = sum_array(a, 4);
```

由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。

如果函数的参数是多维数组，那么除了第一维的长度可以当做参数传入函数，其他维的长度需要写入函数的定义。

```c
int sum_array(int a[][4], int n) {
    // ...
}

int a[2][4] = {
    {1. 2, 3, 4},
     {8, 9, 10, 11}
};
int sum = sum_array(a, 2);
```

上面示例中，函数 sum_array() 的参数是一个二维数组。第一个参数是数组本身（ a[][4] ），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度 4 。

这是因为函数内部拿到的，只是数组的起始地址 a ，以及第一维的成员数量 2 。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成 int a[][4] ，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是 4 * sizeof(int) 。

#### 变长数组作为参数

变长数组作为参数时，写法略有不同

```c
int sum_array(int n, int array[n]) {
    // ...
}

int a[] = {3, 5, 7, 3};
int sum = sum_array(4, a);
```

上面示例中，数组 a[n] 是一个变长数组，它的长度取决于变量 n 的值，只有运行时才能知道。所以，变量 n 作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组 a[n] 的长度，否则就会报错。

因为函数原型可以省略参数名，所以变长数组的原型中，可以使用 * 代替变量名，也可以省略变量名。

```c
int sum_array(int, int [*]);
int sum_array(int, int []);
```

变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。

```c
// 原来的写法
int sum_array(int a[][4], int n);

// 变长数组的写法
int sum_array(int n, int m, int a[n][m]);
```

上面示例中，函数 sum_array() 的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。

#### 数组字面量作为参数

C语言允许将数组字面量作为参数，传入函数。

```c
// 数组变量作为参数
int a[] = {2, 3, 4, 5};
int sum = sum_array(a, 4);

// 数组字面量作为参数
int sum = sum_array((int []){2, 3, 4, 5}, 4);
```

## 七、流程控制

### **break** 语句

注意， break 命令只能跳出循环体和 switch 结构，不能跳出 if 结构。

```c
if (n > 1) {
     if (n > 2) break; // 无效
  printf("hello\n"); 
}
```

## 八、函数

函数的使用和声明，必须声明在前，使用在后

```c
int a = plus_one(13);

int plus_one(int n) {
    return n+1;
}
```

上面这个编译错误

C 语言标准规定，函数只能声明在源码文件的顶层，不能声明在其他函数内部。

### main()

C语言规定，`main()`是程序的入口函数，即所有程序一定要包含一个`main()`函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。

main() 的写法与其他函数一样，要给出返回值的类型和参数的类型，就像下面这样。

```c
int main(void) {
    printf("Hello world\n");
    return 0;
}
```

C语言约定，返回值`0`表示函数运行成功，如果返回其他非零整数，就表示失败。系统根据 main() 的返回值，作为整个程序的返回值，确定程序是否运行成功。

正常情况下，如果 main() 里面省略 return 0 这一行，编译器会自动加上，即 main() 的默认返回值为0。

### 参数的传值引用

如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身,下面交换值，是无效的

```c
void Swap(int x, int y) {
  int temp;
  temp = x;
  x = y;
  y = temp;
}
int a = 1;
int b = 2;
Swap(a, b); // 无效
```

如果想要传入变量本身，就只有一个办法，传入变量的地址。

```c
void Swap(int* x, int* y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

int a = 1;
int b = 2;
Swap(&a, &b);
```

上面示例中，通过传入变量 x 和 y 的地址，函数内部就可以直接操作该地址，从而实现交换两个变量的值。

在这里特别提一下，函数不要返回内部变量的指针。

```c
int* f(void) {
    int i;
    // ...
    return &i;
}
```

上面的例子中，函数返回内部变量i的指针，写法是错误的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量i的内存地址就是无效的，再去使用这个地址是非常危险的。

### 函数指针

函数本身就是一段内存里面的代码，C语言允许通过指针获取函数。

```c
void print(int a) {
    printf("%d\n", a);
}
void (*print_ptr)(int) = &print;
```

上面示例中，变量`print_ptr` 是一个函数指针，它指向函数 print() 的地址。函数 print() 的地址可以用 &print 获得。注意， `(*print_ptr)` 一定要写在圆括号里面，否则函数参数 (int) 的优先级高于`*` ，整个式子就会变成 `void* print_ptr(int)`。

有了函数指针，通过它也可以调用函数。

```c
(*print_ptr)(10);
//等同于
print(10)
```

比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说， print 和 &print 是一回事。

```c
if (print == &print) // true
```

因此，上面代码的 print_ptr 等同于 print 。

```c
void (*print_ptr)(int) = &print;
// 或
void (*print_ptr)(int) = print;

if (print_ptr == print) // true
```

所以，对于任意函数，都有五种调用函数写法

```c
// 写法一
print(10);

// 写法二
(*print)(10)

// 写法三
(&print)(10)

// 写法四
(*print_ptr)(10)

// 写法五
print_ptr(10)
```

为了简洁易读，一般情况下，函数名前面都不加`*`和`&`。

这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。

```c
int compute(int (*myfunc)(int), int, int);
```

上面示例可以清晰地表明，函数 compute() 的第一个参数也是一个函数。

### 函数原型

函数原型是为了解决函数必须先声明，后使用。由于程序总是先运行 main() 函数，导致所有其他函数都必须在main() 函数之前声明。

要解决上面的问题，可以在程序开头处给出函数原型，函数可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。

```c
int twice(int);
int main(int num) {
  return twice(num);
}
int twice(int num) {
  return 2 * num;
}
```

一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。

### exit()

`exit()`函数用来终止整个程序的运行。改函数的原型定义在头文件`stdlib.h`

exit() 可以向程序外部返回一个值，它的参数就是程序的返回值。。一般来说，使用两个常量作为它的参数： EXIT_SUCCESS （相当于 0）表示程序运行成功， EXIT_FAILURE （相当于 1）表示程序异常中止。这两个常数也是定义在 stdlib.h 里面。

```c
// 程序运行成功
// 等同于exit(0)
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于exit(1)
exit(EXIT_FAILURE)
```

在 main() 函数里面， exit() 等价于使用 return 语句。其他函数使用 exit() ，就是终止整个程序的运行，没有其他作用。

C 语言还提供了一个 atexit() 函数，用来登记 exit() 执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件 stdlib.h 。

```C
int atexit(void (*func)(void));
```

`atexit()`的参数是一个函数的指针。注意，他的参数函数（下例的`print`）不能接收参数，也不能有返回值

```c
void print(void) {
    printf("something wrong!\n");
}
atexit(print);
exit(EXIT_FAILURE);
```

上面示例中， exit() 执行时会先自动调用 `atexit()` 注册的 `print() `函数，然后再终止程序。

### 函数说明符

#### extern说明符

对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用 extern 说明该函数的定义来自其他文件。

```c
extern int foo(int arg1, int arg2);

int main(void) {
    int a = foo(2, 3);
    // ...
    return 0;
}
```

由于函数原型默认就是 extern ，所以这里不加 extern ，效果是一样的。

#### **static** 说明符

默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。 static说明符可以改变这种行为。

static 用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。

```c
#include <stdio.h>

void counter(void) {
    static int count = 1; // 只初始化一次
    printf("%d\n", count);
    count++;
}

int main(void) {
    counter(); // 1
    counter(); // 2
    counter(); // 3
    counter(); // 4
    counter(); // 5
}
```

前面示例中，函数 counter() 的内部变量 count ，使用 static 说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。

注意：使用`static`修饰变量初始化时，只能复制为常量，不能赋值为变量。

```c
int i = 3;
static int j = i; // 错误
```

上面示例中， j 属于静态变量，初始化时不能赋值为另一个变量 i 。

另外，在块作用域中， static 声明的变量有默认值 0 。

```c
static int foo;
// 等同于
static int foo = 0；
```

```static```可以用来修饰函数本身。

```c
static int Twice(int num) {
    int result = num * 2;
    return result;
}
```

上例，`static`关键字表示改函数只能在当前文件使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数的原型）。

`static`也可以用在参数里面，修饰参数数组。

```c
int sum_array(int a[static 3], int n) {
    
}
```

上面示例中， static 对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数， static 仅可用于第一维的说明。

#### **const** 说明符

函数参数里面的 const 说明符，表示函数内部不得修改该参数变量

```c
void f(int* p) {
  // ...
}
```

上面示例中，函数 f() 的参数是一个指针 p ，函数内部可能会改掉它所指向的值 *p ，从而影响到函数外部。

为了避免这种情况，可以在声明函数时，在指针参数前面加上 const 说明符，告诉编译器，函数内部不能修改该参数所指向的值

```c
void f(const int* p) {
    *p = 0; // 改行报错
}
```

上面这种写法，只限制修改 p 所指向的值，而 p 本身的地址是可以修改的。

```c
void f(const int* p) {
    int x = 13;
    p = &x;
}
```

上面示例中， p 本身是可以修改， const 只限定 *p 不能修改。如果想限制修改 p ，可以把 const 放在 p 前面。

```c
void f(int* const p) {
    int x = 13;
    p = &x; // 该行报错
}
```

如果想要同时限制修改`p`和`*p`,需要使用两个`const`

```c
void f(const int* const p) {
    // ..
}
```

### 可变参数

有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号 ... 表示可变数量的参数。

```c
int printf(const char* format, ...);
```

这里面还有其他内容，我不理解，所以没记

## **九、**C语言的内存管理

### 简介

C语言内存管理，分成两部分。一是系统管理，二是用户手动管理。

系统管理的内存：主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为“栈”

用户手动管理的内存。主要是程序运行的整个过程中都存在的变量（全局变量）。这些变量需要用户手动从内存释放。如果使用后忘记释放，他就一直占用内存，知道程序退出，这种情况称为`内存泄露`。这些变量所在的内存称为“堆”

### **void** 指针

每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须要有类型，否则编译器就无法知道，如何解读内存块保存的二进制数据。但是，在向系统请求内存的时候，有时候不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。

为了满足这种需求，C语言提供了一种不定类型的指针，叫做viod指针。它只是内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。

另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针

```c
int x = 10;

void* p = &x; // 整数指针转为void指针
int* q = p; //void指针转为整数指针
```

注意，由于不知道 void 指针指向什么类型的值，所以不能用 * 运算符取出它指向的值。

```c
char a = 'x';
void* p = &a;

printf("%c\n", *p); //报错
```

上面示例中， p 是一个 void 指针，所以这时无法用 *p 取出指针指向的值。

void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息。

### malloc()

`malloc()`函数用于分配内存，该函数向系统要求一段内存，系统就在“堆‘里面分配一段连续的内存块给它。它的原型定义在头文件 `stdlib.h` 。

```c
void* malloc(size_t size)
```

它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为 malloc() 函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。

可以使用malloc() 为任意类型的数据分配内存，常见的做法是先使用 sizeof() 函数，算出某种数据类型所需的字节长度，然后再将这个长度传给 malloc() 。

```c
int* p = malloc(sizeof(int));

*p = 12;
printf("%d\n", *p); // 12
```

上面示例中，先为整数类型分配一段内存，然后将整数 12 放入这段内存里面。这个例子其实不需要使用 malloc() ，因为 C 语言会自动为整数（本例是 12 ）提供内存。

有时候为了增加代码的可读性，可以对`malloc()`返回的指针进行一次强制类型转换。

```c
int* p = (int*) malloc(sizeof(int));
```

上面代码将 malloc() 返回的 void 指针，强制转换成了整数指针。

由于 sizeof() 的参数可以是变量，所以上面的例子也可以写成下面这样。

```c
int* p = (int*)malloc(sizeof(*p));
```

malloc() 分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括 stdlib.h 等多个头文件里面都有定义，所以只要可以使用 malloc() ，就可以使用 NULL 。由于存在分配失败的可能，所以最好在使用 malloc() 之后检查一下，是否分配成功。

```c
int* p = malloc(sizeof(int));

if (p == NULL) {
    //分配内存失败
}

// or
if (!p) {
    // ...
}
```

malloc() 最常用的场合，就是为数组和自定义数据结构分配内存。

```c
int* p = (int*)malloc(sizeof(int) * 10);

for (int i = 0; i < 10; i ++) {
    p[i] = i * 5;
}
```

上面示例中， p 是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。(为什么是p[i]而不是*(p)[i]?前面的内容有讲)

malloc() 用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。

```c
int* p = (int*) malloc(n * sizeof(int));
```

上面示例中， malloc() 可以根据变量 n 的不同，动态为数组分配不同的大小。

注意， malloc() 不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用strcpy() 函数。

```c
char* p = malloc(4);
strcpy(p, "abc");

// or
p = "abc"
```

上面示例中，字符指针 p 指向一段4个字节的内存， strcpy() 将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。（我想不明白为什么和上面的一段不同？为什么这里不用*p去赋值）
