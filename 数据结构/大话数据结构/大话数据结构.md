# 大话数据结构

## 研读方法

- 具有c语言基础
- 阅读一遍建议从头到尾进行
- 阅读时，学会摘抄
- 阅读每一章时，特别是阅读算法的推到过程，一定要在电脑中运行代码，了解代码运行过程（用开发工具调试，设置断点和逐步执行）
- 阅读完每一章，一定要在理解的基础上记忆一些关键的东西。最佳效果就是你可以不看书也做到一点不错的默写相关算法
- 阅读完每一章都需要做联系
- 书中有推荐相关的数据结构算法的书，可以自行研究
- 应用到工作当中

## 第一章 数据结构绪论

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。

程序设计=数据结构+算法

### 1.4 基本概念和术语

#### 1.4.1 数据

**数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合**。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。

数据其实就是符号，而这些符号必须具备两个前提：

- 可以输入到计算机中。
- 能被计算机程序处理。

#### 1.4.2 数据元素

**数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。**

比如：在人类中，什么是数据元素？当然是人，畜类呢？牛、羊、马等。

#### 1.4.3 数据项

**数据项：一个数据元素可以由若干数据项组成。**

比如人这样的数据元素，可以有眼、耳、鼻、嘴、手、脚这些数据项，也可以有姓名、年龄、性别、出生地址、联系电话等数据项

**数据项是数据不可分割的最小单位。**（虽然，数据项是数据的最小单位。但真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点）

#### 1.4.4 数据对象

数据对象：是性质相同的数据元素的集合，是数据的子集。

#### 1.4.5 数据结构

结构，简单理解就是关系。在现实世界中，**不同元素之间不是独立的，而是存在特定的关系，我们将这些关系称之为结构**。

**数据结构：是相互之间存在一种或多种特定关系的数据元素的集合**

### 1.5 逻辑结构与物理结构

详见[1.5 逻辑结构与物理结构.xmind]()

### 1.6 数据类型

数据类型：是指一组性质相同的值的集合及定义在集合上的一些操作的总称。

#### 1.6.1 数据类型的定义

- 原子类型
- 结构类型

#### 1.6.2 抽象数据类型

抽象数据类型：一个数学模型及定义在该模型上的一组操作。

### 1.7 总结回顾

数据结构的相关概念，如下图：

![](https://raw.githubusercontent.com/577961141/static/master/20230315182520.png)

数据结构的分类

![](https://raw.githubusercontent.com/577961141/static/master/20230315182717.png)

## 第二章  算法

算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个动作。

### 2.4 算法的定义

什么是算法？算法是描述解决问题的方法。

算法的定义：算法是解决特定问题求解步骤的描述， 在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

### 2.5 算法的特性

![](https://raw.githubusercontent.com/577961141/static/master/20230315190843.png)

- 输入：可以有零个或者多个输入

- 输出：一定要有输出。可以是1个或者多个（打印也算输出）

- 有穷性：指算法在执行有限步骤后，自动结束而不会无限循环，并且每一步骤都在可接受的时间完成。（这里的有穷性，并不是数学意义上的，比如，你的算法执行了20年后才结束，在数据意义上是有穷，但是算法的意义就不大了）

- 确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。（如：同一种输入，只能有同一种结果）

- 可行性：算法的每一个步骤都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

### 2.6 算法设计的要求

![](https://raw.githubusercontent.com/577961141/static/master/20230315190918.png)



- 正确性

- 可读性
- 健壮性：比如能够处理输入的负的时间。
- 时间效率高和存储量低

### 2.7 算法效率度量的方法

#### 2.7.1 事后统计方法

缺陷：

- 必须依据算法事先编制好程序，这样花费大量的时间和精力，如果编制出来发现它根本就是很糟糕的算法，就没意义了
- 时间的比较依赖计算机软件和硬件等环境因素.比如：cup的占用，不同型号的硬件等等
- 算法测试数据设计困难。如果数据量少了，不同算法之间基本没差异，如果数据量大了，比如100万条，不同算法就会有巨大差异

综上，事后统计方法不合理

#### 2.7.2 事前分析估算方法

事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

一个高级语言程序编写的程序在计算机上运行所消耗的时间取决于下面几个因素：

- 算法采用的策略、方法
- 编译产生的代码质量（软件相关）
- 问题的输入规模
- 机器执行指令的速度（硬件相关）

抛开这些与计算机软件和硬件相关的因素，一个程序的运行时间，依赖于算法的好坏和问题输入的规模。所谓问题输入规模值输入量是多少。

>不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，最终，分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤

我们在分析一个算法的运行时间时，**重要的是把基本操作的数量和输入规模关联起来**，即基本操作的数量必须表示成输入规模的函数，如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230316092210.png)

### 2.8 函数的渐近增长

函数的渐近增长：如果存在函数f(n)和g(n)，当n大于某个整数N，总是有f(n)>g(n)，那么，我们就说f(n)的增长渐近快于g(n)。

判断一个算法的效率时，函数的常数项和次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。如：2n^2+3n+1，其中常数项为1,n为次要项，n^2为主要项

### 2.9 算法时间复杂度

#### 2.9.1 算法时间复杂度定义

时间复杂度-我们称为大O记法

O(1)叫常数阶，O(n)叫线性阶，O(n^2)叫平方阶。还有其他阶

#### 2.9.2 推导大O阶方法

- 用常数1取代运行时间中所有加法常数
- 在修改后的运行次数函数中，只保留最高阶
- 如果最高阶存在且系数不是1，则去除与这个阶相乘的系数。

得到的结果就是大O阶

#### 2.9.3常数阶 

适用于分支结构和顺序结构。

#### 2.10 常见的时间复杂度

常见时间复杂度锁耗费时间从小到大的次序是：

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^N)
```

#### 2.11 最坏情况与平均情况

平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

平均时间复杂度和最坏时间复杂度，一般没有特别说明时间复杂度就是最坏时间复杂度

#### 2.12 空间复杂度

如果不用先定词地使用“复杂度”，通常指的是时间复杂度

## 第三章 线性表

### 3.2 线性表的定义

定义：零个或多个数据元素的有限序列。

- 是有相同性质的数据类型（人和背包排队的例子，背包就不能和人相提并论）

- 有限：有限个数。

- 序列：按照顺序排，一个接一个

  ![](https://raw.githubusercontent.com/577961141/static/master/20230317093102.png)

若线性表记为（a1,...,ai-1,ai,ai+1...an），称ai-1是ai的**直接前驱元素**，ai+1是ai的**直接后驱元素**

线性表的长度n>=0;n=0的时候称之为**空表**

在非空表中的每个数据元素都有-个确定的位置,如a1是第—个数据元素, an是最后一个数据元素，aj是第j个数据元素，称j为数据元素aj在线性表中的**位序**。

### 3.3 线性表的抽象数据类型

线性表的抽象数据类型定义如下：

```
ADT 线性表（List）
Data
	线性表的数据对象集合为{a1,a2, ..., an},每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L):初始化操作，建立一个空的线性表L。
	ListEmpty(L)：若线性表为空，返回true，否则返回false
	ClearList(*L):将线性表清空
	GetElem(L, i, *e):将线性表L中第i个位置元素返回给e。
	LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
    ListInsert(*L, i, e): 在线性表中的第i个位置插入新元素e
    ListDelete(*L, i, *e):删除线性表L中第i个位置的元素，并用e返回其值
    ListLength(L)：返回线性表L的元素个数
endADT
```

混淆点

>当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。
>
>- 如果需要被改动，则需要传递指向这个参数的指针
>- 如果不用被改动，可以直接传递这个参数

### 3.4 线性表的顺序存储结构

#### 3.4.1 顺序存储定义

线性表有两种物理结构，这是其中之一

线性表的顺序存储结构，指的是用一段地址连续地址的存储单元依次存储线性表的数据元素。

示意图如下：

![](https://raw.githubusercontent.com/577961141/static/master/20230320090205.png)

#### 3.4.2 顺序存储方式

线性表的顺序存储结构，说白了，就是在内存中找一块地儿，通过占位的形式，把一定内存空间给占用了。

线性表中的每个数据元素的类型都是相同的，所以可以用C语言的一维数组来实现顺序存储结构

线性表顺序存储的代码如下
```C
#define MAXSIZE 20
typedef int ElemType;
typedef struct {
  ElemType data[MAXSIZE];
  int length;
}SqList;
```

描述顺序存储结构的三个属性：
- 存储空间的起始位置：数据data。它的存储位置就是存储空间的存储位置。
- 线性表的最大存储容量：数组长度MAXSIZE。
- 线性表的当前长度：length。

#### 3.4.3 数据长度和线性表的长度

数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。（C的数组存储空间可以通过动态分配改变，但是会消耗性能）

线性表的长度是线性表中数据元素的个数，随着线性表的插入和删除操作进行，这个量是变化的。

在任何时刻，线性表长度都应该小于等于数组的长度

#### 3.4.4 地址计算方法

存储器中的每个存储单元都有自己的编号，这个编号称为地址。

后面的内容没懂

存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为**随机存取结构**（数组的存取不是O(n)?）

### 3.5  顺序存储的插入与删除

#### 3.5.1 获取元素操作

写代码

#### 3.5.2 插入操作

书上说，插入操作的时间复杂度是O(1)（按照以往的理解，数组的插入操作的时间复杂度为O(N)才对）

写代码

#### 3.5.3 删除操作

写代码

总结：读取的时间复杂度为O(1)，插入和删除的时间复杂度为O(n)，插入和删除的平均也为时间复杂度为O(n)。这说明，它比较是和元素个数不太变化，而更多是存储数据的应用。

#### 3.5.4 线性表顺序存储结构的优缺点

优点：

- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中任一个位置的元素

缺点：

- 插入和删除操作需要移动大量的元素
- 当线性表变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片”

### 3.6 线性表的链式存储结构

#### 3.6.2 线性表链式存储结构定义

线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

在顺序结构当中，每个数据元素中只需要存储数据元素信息就可以了。在链式结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址。

数据域：我们把存储数据元素信息的域称为数据域。

指针域：我们把存储直接后继位置的域称为指针域。（指针域中存储的信息称为指针或链）

结点：这两部分信息组成数据元素a1的存储映像，称为**结点（NODE）**

n个结点（a1的存储映像）链结成一个链表即为线性表的链式存储结构。（如果链表的每个结点中只包含一个指针域，所以叫单链表）

头指针：链表中第一个结点的存储位置叫头指针。

头结点：在**单链表**的第一个节点前附设一个节点，称为头结点。

#### 3.6.3 头指针与头结点的异同

头指针
- 头指针是指向链表第一个结点的指针，若链表有头结点，则指向头结点的指针
- 头指针具有标示作用，所以常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不为空。头指针是链表的必要元素

头结点
- 头结点是为了操作方便和统一而设立的，放在第一个元素的结点之前，其数据域一般无意义（也可以存放链表的长度）。
- 有了头结点，对第一个元素节点前插入节点和删除第一个结点，其操作和其他节点的操作就统一了
- 头结点不一定是链表的必要元素

### 3.7 单链表的读取

写代码

### 3.8 单链表的插入与删除

#### 3.8.1 单链表的插入

写代码

#### 3.8.2 单链的删除

写代码

总结： 对于插入或删除数据越频繁的操作，单链表的效率优势越明显

### 3.9 单链表的整表创建

写代码

### 3.10 单链表的整表删除

写代码

### 3.11 单链表结构与顺序存储的优缺点：
- 存储分配方式
  - 顺序存储结构用一段连续存储单元存储线性表的数据元素
  - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的数据元素
- 时间性能
  - 查找
    - 顺序存储结构：O(1)
    - 单链表：O(n)
  - 插入和删除
    - 顺序存储结构需要平均移动表长一般的元素，时间复杂度为O(n)
    - 单链表在找出位置的指针后，插入和删除时间复杂度为O(1)
- 空间性能
  - 顺序存储结构需要预分配存储空间、分大了，浪费，分小了，容易发生上溢
  - 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限

通过上面的比较得出以下结论：
- 若线性表需要频繁查找，很少进行插入和删除时，采用顺序存储结构。反之，如果插入和删除比较多，查找少，采用单链表结构
- 当线性表中的元素个数变化较大或者根本不知道多大时，采用单链表结构。

### 3.12 静态链表

静态链表：用数组描述的链表（有些语言是没有指针的，只能通过数组来实现链表）

静态链表定义代码：
```c
#define MAXSIZE 1000 /* 存储空间初始分配量，要尽量足够大,防止溢出 */

typedef struct {
  ElemType data;
  int cur; /* 游标，为0时表示无指向 */
} Component， StaticLinkList[MAXSIZE];
```

静态链表相关信息：
1. 备用链表：未被使用的数组元素称为备用链表。
2. 需要对数组的第一个和最后一个元素进行特殊处理，**不存数据**
  - 数组的第一个元素，即标为0的元素的cur就存放备用链表的第一个结点的下标；
  - 数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于链表中头结点的作用，当整个链表为空时，怎为0。

怎么理解2，请看下图
![](https://raw.githubusercontent.com/577961141/static/master/20230323092751.png)

初始化静态链表的代码：

```c
/*将—维数组space中分量炼成一个备用链表 */
Status initList(StaticLinkList space) { /* 为什么不是引用，因为模拟的就是没有引用的语言啊 */ 
  int i;
  
  for (i = 0; i < MAXSIZE; i++) {
    space[i].cur = i+1;
  }
  space[MAXSIZE-1].cur = 0; /* 因为初始化的时候链表是为空的，所以最后一个数组元素的cur指向0 */
  
  return OK;
}
```

#### 3.12.1 静态链表的插入操作

静态链表的插入，要实现类似C语言的申请空间`malloc()`函数。为了辨明数组中哪些分量未被使用，解决办法就是将所有未被使用过的及已被删除的分量用游标链成一个备用链表，每当进行插入时，便可以从备用链表上取得第一个节点作为待插入的新结点.函数实现如下

```c
/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */
Statuc Malloc_SSL(StaticLinkList space) {
    int i = space[0].cur;   /* 当前数组第一个元素的cur存的值 */
                            /* 就是要返回的第一个备用空闲的下标 */
    if (space[0].cur) {
        space[0].cur = space[i].cur     /* 由于要拿出一个分量来使用了， */
                                        /* 所以我们就得把它的下一个 */
                                        /* 分量用来做备用 */
    }

    return i;
}
```

如果代码不理解请看书

那么插入代码如下：

```c
/*  在L中第i个元素之前插入新的数据元素e   */
Status ListInsert(StaticLinkList L, int i, ElemType e) 
{
    int j, k, l;
    k = MAXSIZE - 1; /* 注意k首先是最后一个元素的下标 */
    if (i < 1 || i > ListLength(L) + 1) {
         // 不能是第0个位置(存放了标识元素) || 
         // 也不能大于当前数组的长度加1（在我的理解中，应该也不可以等于链表的长度，因为最后一个也有标识元素。只有当标识元素在比数组长度还大1才说的通）
         // j = Malloc_SSL(L);里面限制了，没有就不加元素了
        return ERROR;
    }
    j = Malloc_SSL(L); /* 获得空闲分量的下标 */
    if (j) {
        L[j].data = e; /* 将数据赋值给此分量的data */
        for(l = 1; l <= i-1; i++) {  /* 找到第i个元素之前的位置 */
            k = L[k].cur;
        }
        L(j).cur = L[k].cur;  /* 把第i个元素之前的cur赋值给新元素的cur */
        L[K].cur = j;  /* 把新元素的下标赋值给第i个元素之前元素的ur */
        return OK;
    }
    return ERROR;
}
```

不理解请看书。

#### 3.12.2 静态链表的删除操作

静态链表的删除操作，要实现类似于c的释放结点函数free().

代码请看书。

#### 3.12.3静态链表的优缺点

- 优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量的元素的缺点。
- 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了链式存储结构随机存取的特性。

### 3.13 循环链表

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325000245.png)

这种头尾相接的单链表称为**单循环链表**，简称循环链表（circular linked list）.

循环链表带有头结点的空链表如下：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325000549.png)

对于非空的循环链表就如下图表示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325000613.png)

其实循环链表和单链表的差异就在于循环条件的判断上，原来是判断`p->next`是否为空。现在是`p->next`不等于头结点，则循环为结束。

在单链表中，我们有了头结点，我们可以用O(1)的时间来访问第一个节点，但对于要访问最后一个节点，却需要O(n)时间。

有没有能用O(1)的时间由链表指针访问最后一个结点呢？当然可以。

不过我们需要改造一下这个循环链表’不用头指针’而是用指向终端结点的尾指针来表示循环链表（如下图所示） ,此时查找开始结点和终端结点都很方便了°

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325001026.png)

这样头尾查找到的都是O(1)。

再举个例子，将两个循环链表合并成一个表时，有尾指针就非常简单了。两个循环链表如下所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325001208.png)

要合并可以像如下图操作：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230325001241.png)

```c
p = pearA->next;
rearA->next = rearB->next->next;

q = rearB->next;
rearB->next = p;
free(q)
```

### 3.14 双向链表

双向链表（double linked list）是在单链表的每个结点中，再设置一个指向器前驱节点的指针域。如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230325085207.png)

这样的话双向链表中的每个节点有两个指针域。一个指向直接后继，另一个指向直接前驱。这样的话，如果知道了某个节点，那么直接获取其前一个元素和后一个元素，时间复杂度都是O(1).(单链表获取某个结点的前一个结点时间复杂度为O(n))

双向链表的定义如下

```c
typedef struct DulNode 
{
    Elemtype data;
    struct DuLNode *prior; /* 直接前驱指针 */
    struct DoLNode *next; /* 直接后继指针 */
}DulNode， *DuLinkList;
```

双向链表也有循环链表。

双向链表的循环带头结点的空链表如下：

![](https://raw.githubusercontent.com/577961141/static/master/20230325085806.png)

非空的循环带头节点的双向链表如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230325085831.png)

双向链表的某个节点p的后继的前驱与前驱的后继指向的就是自己，即

```c
p->next->priot = p->prior->next
```

双向链表的很多操作和单向链表是相同的，如获取长度`ListLength`，查找元素`GetElem`等

双向链表既然比单链表多了如可以反向遍历查找等数据结构，那么需要付出一点代价：在插入和删除的时候要改变两个指针的变量。

插入操作时，要**特别注意顺序**。如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230325090304.png)

```c
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
```

删除操作只需要两个步骤，如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230325090442.png)

```c
p->prior = p->next;
p->next->prior = p->prior;
free(p);
```

双链表是的为某个结点的前后结点操作带来了方便，但是需要占用额外的空间（以时间换空间）

