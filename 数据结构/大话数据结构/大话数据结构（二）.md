# 大话数据结构（二）

## 第四章 栈和队列

栈和队列： 栈是限定仅在表尾进行插入和删除操作的线性表。队列是允许在一端进行插入操作，而在另一端进行删除操作的线性表。

### 4.2 栈的定义

> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

**概念**

- 栈顶：允许插入和删除的一端称之为栈顶。
- 栈底：与栈顶相反
- 空栈：不含任何数据元素的栈称为空栈。
- LIFO结构：是Last In First Out（后进先出）


理解栈的定义需要注意如下几点：
- 它是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系
- 定义中说的是在线性表的表尾进行插入和删除操作，这里的表尾值的是栈顶，而不是栈底

栈的插入操作称为进栈（也称亚栈、入栈）
栈的删除操作称为出栈（也称为弹栈）

### 4.3 栈的抽象数据类型

```c
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序存储结构

栈的顺序存储结构用数组实现。以0的那一端作为栈底，另一端为栈顶

栈的结构定义如下

```c
typedef int SElemType;

tupedef struct {
    SElemType data[MAXSIZE];
    int top;                   /* 用于栈顶指针 */
}SqStack;
```

#### 4.4.2 栈的顺序存储结构-进栈操作

代码如下：

```c
Status Push(SqStack *S, SElemType e) 
{
    if (S->top == MAXSIZE - 1)  /* 栈满了 */
    {
        return ERROR;
    }
    S->top++;
    S->data[S->top]=e;
    return OK;
}
```

#### 4.4.3 栈的顺序存储空间-出栈操作

代码如下：

```c
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == -1) {
        return OK;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

### 4.5 两栈共享空间

如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这个时候我们完全可以用一个数组来存储快两个栈，充分利用这个数组占用的内存空间。

做法如下图所示。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标的n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305051832555.png)

从这里分析出，若栈1为空时，top1等于-1；若栈2为空时，top2等于n。

栈满分为三种情况：
- 栈1满：top1=n-1，top2=n
- 栈2满：top1=-1，top2=0
- 栈满：top1+1 = top2

两栈共享空间结构的代码如下：

```c
typedef struct {
    SElemType data[MAXSIZE];
    int top1;
    int top2;
}SqDoubleStack;
```

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要判断时栈1还是栈2的栈号参数stackNumber，插入元素的代码如下：

```c
Status Push(SqDoubleStack *S, SElemType e, int stackNumber) {
    if (S->top1+1 == S->top2) { // 栈满
       return ERROR;
    }
    
    if (stackNumber == 1) { // 栈1
        S->data[++S->top1] = e;
    }
    
    if (stackNumber == 2) { // 栈1
        S->data[--S->top2] = e;
    }
    
    return OK;
}
```

因为在代码开始时已经判断了是否有栈满的情况,所以后面的top1+1或top2是不担心溢出问题的.

对于两栈共享空间pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下

```c
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber) {
    if (stackNumber == 1) {
        if (S->top1 == -1) {
            return ERROR;
        }
        
        *e = S->data[S->top1--];
    } else if (stackNumber == 2) {
         if (S->top1 == MAXSIZE) {
            return ERROR;
        }
        
        *e = S->data[S->top2++];
    }
}
```

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

栈的链式存储，称为链栈。

链栈与链表注意点：
- 栈顶放在链表的头部
- 单链表的头指针和栈顶指针合二为一
- 不需要头结点（累赘）
- 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
- 对于链栈来说，链表原定义式指针指向空，那么链栈的空其实就是top=NULL的时候。

链栈的结构代码如下：

```c
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct 
{
    LinkStackPtr top;
    int count;
}LinkStack;
```

链栈的操作绝大部分和单链表类似，只是插入和删除上，特殊一点。

#### 4.6.2 栈的链式存储结构-进栈操作

代码如下所示

```c
Status Push(LinkStack *S, SElemType e){
    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 栈的链式存储结构-出栈操作

代码如下：

```c
Status Pop(LinkStack *S, SElemType *e) {
    LinkStackPtr p;
    if (StackEmpty(*S)){
        return ERROR;
    }
    *e = S->top->data;
    p = S->top;
    S->top=S->top->next;
    free(p);
    S->count--;
    return OK;
}
```

栈选用顺序存储还是链式存储：如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那就用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好。