# 大话数据结构（二）

## 第四章 栈和队列

栈和队列： 栈是限定仅在表尾进行插入和删除操作的线性表。队列是允许在一端进行插入操作，而在另一端进行删除操作的线性表。

### 4.2 栈的定义

> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

**概念**

- 栈顶：允许插入和删除的一端称之为栈顶。
- 栈底：与栈顶相反
- 空栈：不含任何数据元素的栈称为空栈。
- LIFO结构：是Last In First Out（后进先出）


理解栈的定义需要注意如下几点：
- 它是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系
- 定义中说的是在线性表的表尾进行插入和删除操作，这里的表尾值的是栈顶，而不是栈底

栈的插入操作称为进栈（也称亚栈、入栈）
栈的删除操作称为出栈（也称为弹栈）

### 4.3 栈的抽象数据类型

```c
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序存储结构

栈的顺序存储结构用数组实现。以0的那一端作为栈底，另一端为栈顶

栈的结构定义如下

```c
typedef int SElemType;

tupedef struct {
    SElemType data[MAXSIZE];
    int top;                   /* 用于栈顶指针 */
}SqStack;
```

#### 4.4.2 栈的顺序存储结构-进栈操作

代码如下：

```c
Status Push(SqStack *S, SElemType e) 
{
    if (S->top == MAXSIZE - 1)  /* 栈满了 */
    {
        return ERROR;
    }
    S->top++;
    S->data[S->top]=e;
    return OK;
}
```

#### 4.4.3 栈的顺序存储空间-出栈操作

代码如下：

```c
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == -1) {
        return OK;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

### 4.5 两栈共享空间

如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这个时候我们完全可以用一个数组来存储快两个栈，充分利用这个数组占用的内存空间。

做法如下图所示。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标的n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305051832555.png)

从这里分析出，若栈1为空时，top1等于-1；若栈2为空时，top2等于n。

栈满分为三种情况：
- 栈1满：top1=n-1，top2=n
- 栈2满：top1=-1，top2=0
- 栈满：top1+1 = top2

两栈共享空间结构的代码如下：

```c
typedef struct {
    SElemType data[MAXSIZE];
    int top1;
    int top2;
}SqDoubleStack;
```

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要判断时栈1还是栈2的栈号参数stackNumber，插入元素的代码如下：

```c
Status Push(SqDoubleStack *S, SElemType e, int stackNumber) {
    if (S->top1+1 == S->top2) { // 栈满
       return ERROR;
    }
    
    if (stackNumber == 1) { // 栈1
        S->data[++S->top1] = e;
    }
    
    if (stackNumber == 2) { // 栈1
        S->data[--S->top2] = e;
    }
    
    return OK;
}
```

因为在代码开始时已经判断了是否有栈满的情况,所以后面的top1+1或top2是不担心溢出问题的.

对于两栈共享空间pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下

```c
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber) {
    if (stackNumber == 1) {
        if (S->top1 == -1) {
            return ERROR;
        }
        
        *e = S->data[S->top1--];
    } else if (stackNumber == 2) {
         if (S->top1 == MAXSIZE) {
            return ERROR;
        }
        
        *e = S->data[S->top2++];
    }
}
```

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

栈的链式存储，称为链栈。

链栈与链表注意点：
- 栈顶放在链表的头部
- 单链表的头指针和栈顶指针合二为一
- 不需要头结点（累赘）
- 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
- 对于链栈来说，链表原定义式指针指向空，那么链栈的空其实就是top=NULL的时候。

链栈的结构代码如下：

```c
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct 
{
    LinkStackPtr top;
    int count;
}LinkStack;
```

链栈的操作绝大部分和单链表类似，只是插入和删除上，特殊一点。

#### 4.6.2 栈的链式存储结构-进栈操作

代码如下所示

```c
Status Push(LinkStack *S, SElemType e){
    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 栈的链式存储结构-出栈操作

代码如下：

```c
Status Pop(LinkStack *S, SElemType *e) {
    LinkStackPtr p;
    if (StackEmpty(*S)){
        return ERROR;
    }
    *e = S->top->data;
    p = S->top;
    S->top=S->top->next;
    free(p);
    S->count--;
    return OK;
}
```

栈选用顺序存储还是链式存储：如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那就用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好。

### 4.7 栈的作用

栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。

### 4.8 栈的应用-递归

#### 4.8.1 斐波那契数列的实现

代码如下：

```c
int Fbi(int i) 
{
    if (i < 2) {
        return i == 0 ?  0 : 1;
    }
    return Fbi(i-1)+Fbi(i-2);
}

int main() 
{
    int i;
    printf("递归显示斐波那契数列：\n");
    for (i = 0; i < 40; i++) {
        printf("%d ", )
    }
    
    return 0;
}
```

#### 4.8.2 递归的定义

定义：我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数称为递归函数。

> 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

### 4.9 栈的应用-四则运算表达式求值

#### 4.9.1 后缀（逆波兰）表示法定义

定义：一种不需要括号的后缀表达式，我们也把它称为逆波兰（Reverse Polish Notation, RPN）表示。

>例子：
>
> 正常表达式：9+(3-1)*3+10/2
>
> 转换为后缀表达式：9 3 1 - 3 * + 10 2 / + 
> 

#### 4.9.2 后缀表达式的计算结果

后缀表达式：9 3 1 - 3 * + 10 2 / + 

规则：从左往右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

具体流程看书（leetcode有一样的题目）

#### 4.9.3 中缀表达式转后缀表达式

中缀表达式的定义：我们平时所用的标准四则运算表达式，如：“9（3-1）*3+10/2”

那么中缀表达式怎么转换为后缀表达式呢？

规则：从左往右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于（小于等于）栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

具体流程看书（leetcode有一样的题目）

总结：
- 将中缀表达式转化为后缀表达式（栈用来进出运算符号）
- 将后缀表达是进行运算得出运算结果（栈用来进出运算的数字）

### 4.10 队列的定义

定义：队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头

### 4.11 队列的抽象数据类型

同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。

```
ADT 队列
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它
    ClearQueue(*Q)：将队列Q清空
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false
    GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素
    EnQueue(*Q, e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素
    DeQueue(*Q, *e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数。
endADT
```

### 4.12 循环队列

具体的最好还是看书比较合适

#### 4.12.1 队列顺序存储的不足

以数组的0为表头，以数组的另一方向为表尾的不足：
- 在表尾插入数据的时间复杂度为O(1)，在表头删除数据的时间复杂度为O(n)
- 为了解决在表头删除的时间复杂度为O(n),引入了两个指针，front指针指向队头元素，rear指向队尾元素的下个元素，如下图所示
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081850726.png)
- 如果表为空则front指针和rear指针指向同一个结点，如下
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081852601.png)
- 那么队列满的时候呢？那么rear就会溢出去？值是什么？不知道
- 看下图，假设这个队列的总个数不超过5个，但是目前如果接着入队，因为数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上队列再下标0和1的地方还是空闲的。这就叫假溢出。
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081856265.png)
    

#### 4.12.2 循环队列的定义

为了解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。***我们把队列的这种头尾相接的顺序存储结构称为循环队列***

分析过程请看书

循环队列相关计算
- 队空：front = rear
- 堆满：front = (rear+1)%QueueSize ***(注：这种方式要付出代价，队列一定要有一个元素不能用)***
- 队列长度公式：(rear-front+QueueSize)%QueueSize
