# 大话数据结构（二）

## 第四章 栈和队列

栈和队列： 栈是限定仅在表尾进行插入和删除操作的线性表。队列是允许在一端进行插入操作，而在另一端进行删除操作的线性表。

### 4.2 栈的定义

> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

**概念**

- 栈顶：允许插入和删除的一端称之为栈顶。
- 栈底：与栈顶相反
- 空栈：不含任何数据元素的栈称为空栈。
- LIFO结构：是Last In First Out（后进先出）


理解栈的定义需要注意如下几点：
- 它是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系
- 定义中说的是在线性表的表尾进行插入和删除操作，这里的表尾指的是栈顶，而不是栈底

栈的插入操作称为进栈（也称压栈、入栈）
栈的删除操作称为出栈（也称为弹栈）

### 4.3 栈的抽象数据类型

```c
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序存储结构

栈的顺序存储结构用数组实现。以0的那一端作为栈底，另一端为栈顶

栈的结构定义如下

```c
typedef int SElemType;

tupedef struct {
    SElemType data[MAXSIZE];
    int top;                   /* 用于栈顶指针 */
}SqStack;
```

#### 4.4.2 栈的顺序存储结构-进栈操作

代码如下：

```c
Status Push(SqStack *S, SElemType e) 
{
    if (S->top == MAXSIZE - 1)  /* 栈满了 */
    {
        return ERROR;
    }
    S->top++;
    S->data[S->top]=e;
    return OK;
}
```

#### 4.4.3 栈的顺序存储空间-出栈操作

代码如下：

```c
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == -1) {
        return OK;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

### 4.5 两栈共享空间

如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这个时候我们完全可以用一个数组来存储快两个栈，充分利用这个数组占用的内存空间。

做法如下图所示。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标的n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305051832555.png)

从这里分析出，若栈1为空时，top1等于-1；若栈2为空时，top2等于n。

栈满分为三种情况：
- 栈1满：top1=n-1，top2=n
- 栈2满：top1=-1，top2=0
- 栈满：top1+1 = top2

两栈共享空间结构的代码如下：

```c
typedef struct {
    SElemType data[MAXSIZE];
    int top1;
    int top2;
}SqDoubleStack;
```

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要判断时栈1还是栈2的栈号参数stackNumber，插入元素的代码如下：

```c
Status Push(SqDoubleStack *S, SElemType e, int stackNumber) {
    if (S->top1+1 == S->top2) { // 栈满
       return ERROR;
    }
    
    if (stackNumber == 1) { // 栈1
        S->data[++S->top1] = e;
    }
    
    if (stackNumber == 2) { // 栈1
        S->data[--S->top2] = e;
    }
    
    return OK;
}
```

因为在代码开始时已经判断了是否有栈满的情况,所以后面的top1+1或top2是不担心溢出问题的.

对于两栈共享空间pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下

```c
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber) {
    if (stackNumber == 1) {
        if (S->top1 == -1) {
            return ERROR;
        }
        
        *e = S->data[S->top1--];
    } else if (stackNumber == 2) {
         if (S->top1 == MAXSIZE) {
            return ERROR;
        }
        
        *e = S->data[S->top2++];
    }
}
```

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

栈的链式存储，称为链栈。

链栈与链表注意点：
- 栈顶放在链表的头部
- 单链表的头指针和栈顶指针合二为一
- 不需要头结点（累赘）
- 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
- 对于链栈来说，链表原定义式指针指向空，那么链栈的空其实就是top=NULL的时候。

链栈的结构代码如下：

```c
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct 
{
    LinkStackPtr top;
    int count;
}LinkStack;
```

链栈的操作绝大部分和单链表类似，只是插入和删除上，特殊一点。

#### 4.6.2 栈的链式存储结构-进栈操作

代码如下所示

```c
Status Push(LinkStack *S, SElemType e){
    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 栈的链式存储结构-出栈操作

代码如下：

```c
Status Pop(LinkStack *S, SElemType *e) {
    LinkStackPtr p;
    if (StackEmpty(*S)){
        return ERROR;
    }
    *e = S->top->data;
    p = S->top;
    S->top=S->top->next;
    free(p);
    S->count--;
    return OK;
}
```

栈选用顺序存储还是链式存储：如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那就用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好。

### 4.7 栈的作用

栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。

### 4.8 栈的应用-递归

#### 4.8.1 斐波那契数列的实现

代码如下：

```c
int Fbi(int i) 
{
    if (i < 2) {
        return i == 0 ?  0 : 1;
    }
    return Fbi(i-1)+Fbi(i-2);
}

int main() 
{
    int i;
    printf("递归显示斐波那契数列：\n");
    for (i = 0; i < 40; i++) {
        printf("%d ", )
    }
    
    return 0;
}
```

#### 4.8.2 递归的定义

定义：我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数称为递归函数。

> 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

### 4.9 栈的应用-四则运算表达式求值

#### 4.9.1 后缀（逆波兰）表示法定义

定义：一种不需要括号的后缀表达式，我们也把它称为逆波兰（Reverse Polish Notation, RPN）表示。

>例子：
>
> 正常表达式：9+(3-1)*3+10/2
>
> 转换为后缀表达式：9 3 1 - 3 * + 10 2 / + 
> 

#### 4.9.2 后缀表达式的计算结果

后缀表达式：9 3 1 - 3 * + 10 2 / + 

规则：从左往右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

具体流程看书（leetcode有一样的题目）

#### 4.9.3 中缀表达式转后缀表达式

中缀表达式的定义：我们平时所用的标准四则运算表达式，如：“9（3-1）*3+10/2”

那么中缀表达式怎么转换为后缀表达式呢？

规则：从左往右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于（小于等于）栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

具体流程看书（leetcode有一样的题目）

总结：
- 将中缀表达式转化为后缀表达式（栈用来进出运算符号）
- 将后缀表达是进行运算得出运算结果（栈用来进出运算的数字）

### 4.10 队列的定义

定义：队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头

### 4.11 队列的抽象数据类型

同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。

```
ADT 队列
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它
    ClearQueue(*Q)：将队列Q清空
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false
    GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素
    EnQueue(*Q, e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素
    DeQueue(*Q, *e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数。
endADT
```

### 4.12 循环队列

具体的最好还是看书比较合适

#### 4.12.1 队列顺序存储的不足

以数组的0为表头，以数组的另一方向为表尾的不足：
- 在表尾插入数据的时间复杂度为O(1)，在表头删除数据的时间复杂度为O(n)
- 为了解决在表头删除的时间复杂度为O(n),引入了两个指针，front指针指向队头元素，rear指向队尾元素的下个元素，如下图所示
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081850726.png)
- 如果表为空则front指针和rear指针指向同一个结点，如下
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081852601.png)
- 那么队列满的时候呢？那么rear就会溢出去？值是什么？不知道
- 看下图，假设这个队列的总个数不超过5个，但是目前如果接着入队，因为数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上队列再下标0和1的地方还是空闲的。这就叫假溢出。
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081856265.png)
    

#### 4.12.2 循环队列的定义

为了解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。***我们把队列的这种头尾相接的顺序存储结构称为循环队列***

分析过程请看书

循环队列相关计算
- 队空：front = rear
- 堆满：front = (rear+1)%QueueSize ***(注：这种方式要付出代价，队列一定要有一个元素不能用)***
- 队列长度公式：(rear-front+QueueSize)%QueueSize

循环队列的顺序存储结构代码如下：

```c
typedef int QElemType;

typedef struct
{
  QElemType data[MAXSIZE];
  int front, rear;  
}SqQueue;
```

循环队列的初始化代码如下：
```c
Status InitQueue(SqQueue *Q) 
{
  Q->front = 0;
  Q->front = 0;
  return OK;
}
```

循环队列求队列长度代码如下

```c
int QueueLength(SqQueue Q) 
{
  return (Q->rear-Q->front+MAXSIZE)%MAXSIZE;
}
```

循环队列入队列操作代码如下：

```c
Status EnQueue(SqQueue *Q, QElemType e)
{
  if ((Q->rear+1)%MAXSIZE == Q->front) { // 满了
    return ERROR;
  }
  
  Q->data[Q->rear] = e;
  Q->rear = (Q->rear+1) % MAXSIZE;
  
  return OK;
}
```

循环队列出队列操作代码如下：

```c
Status DeQueue(SqQueue *Q, QElemType *e) {
  if (Q->rear == Q->front) { // 队列是空的
    return ERROR;
  }
  
  *e = Q->data[Q->front];
  Q->front = (Q->front+1)%MAXSIZE;
  
  return OK;
}
```

### 4.13 链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列
- 头指针指向链队列的*头结点*
- 队尾指针指向终端结点
- 空队列时，front和rear都指向头结点。

链队列的结构如下：

```c
typedef int QElemType;

typedef struct QNode 
{
  QElemType data;
  struct QNode *next;
}QNode, *QueuPtr;

typedef struct 
{
  QueuePtr front, rear;
}LinkQueue;
```

#### 4.13.1 队列的链式存储结构-入队操作

入队时，其实就是在链表尾部插入结点，如下所示。

代码如下：

```c
Status Enqueue(LinkQueue *Q, QElemType e) {
  QueuePtr s=(QueuePtr)malloc(size(QNode));
  if (!s) {
    exit(OVERFLOW);
  }
  s->data = e;
  s->next = null;
  Q->rear->next = s;
  Q->rear = s;
}
```


#### 4.13.2 队列的链式存储结构-出队操作

出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素，则需要rear指向头结点。

代码如下：

```c
Status DeQueue(LinkQueue *Q, QElemType *e) {
  QueuePtr p;
  
  if (Q->front == Q->rear){
    return ERROR;
  }
  
  p = Q->front->next;
  *e = p->data;
  Q->front->next = p->next;
  if (Q->rear == p) {
    Q->rear = Q->front;
  }
  
  free(p);
  return OK;
}
```

对于循环队列与链队列的比较，可以从两方面考虑，时间上，其实它们的基本操作都是常数时间，即都为O(1),不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。

总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，如果你无法预估队列的长度，则用链队列

### 4.14 总结

- 栈和队列都是特殊的线性表，只不过对插入和删除操作做了限制
- 栈是限定仅在表尾进行插入和删除操作的线性表
- 队列是只允许一端进行插入操作，在另一端进行删除操作的线性表
- 它们均可以用线性表的顺序存储结构来实现，但都存在这顺序存储的一些弊端
  - 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端左栈底的方法来让两个栈的共享数据，这就可以最大化利用数组的空间
  - 对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)
- 它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同，如下图所示
![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305091836573.png)

## 第五章 串

### 5.2 串的定义

串：串是由零个或多个字符组成的有限序列，又叫做字符串

概念：

- 串的长度：串中的字符数目n称为串的长度
- 空串：零个字符的串称为空串（null string）。可以直接用双引号“""”表示，也可以用希腊字母“Φ”来表示
- 空格串：是只包含空格的串。空格串是由内容有长度的，而且可以不止一个空格
- 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应的，包含子串的串称为主串
- 子串在主串中的位置就是子串的第一个字符在主串的序号

### 5.3 串的比较

> 计算机中常用字符是发展
> 
> 使用标准的ASCII码，更准确点，由7位二进制数表示一个字符，总共可以表示128个字符
> 
> 扩展ASCII码由8位二进制数表示一个字符，总共可以表示256个字符（能够满足以英语为主的语言和特殊符号，但是不能满足中文）
> 
> Unicode编码，由16位的二进制数表示一个字符，那么就可以表示约6.5万个字符
> 
> 当然，为了和ASCIⅡ码兼容，Unicode的前256个字符与ASCI码完全相同
> 

如果两个串不想等，如何判断他们的大小呢？我们这样定义：

给定两个串：s=“a1, a2,...an”, t="b1,b2,...bm",当满足以下条件之一时s<t

(1) n < m,且ai=bi（i=1,2,...,n）

例如当s=“hap”,t=“happy”,就有s<t。因为t比s多出了两个字母。

(2) 存在某个k<=min(m,n),使得ai=bi(i=1,2,...,k-1), ak<bk

例如当s=“happen”,t=“happy”,因为两串的前4个字母均相同，而两串第5个字 母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然e<y,所以s<t。

### 5.4 串的抽象数类型

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306061914073.png)

### 5.5 串的存储结构

#### 5.5.1 串的顺序存储结构

串的顺序存储结构是一组地址连续的存储单元来存储串中的字符序列的。按照与定义的大小，为每个定义的串的变量分配一个固定长度的存储区。一般用定长数组来定义。

定长数组存储串有两种形式

- 将串的实际长度值存在数组的0下标位置。如下图所示。

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070828560.png)
- 在串值后面加一个不计入串长度的结束标记字符，如“\0”来表示串的终结，这个时候要计算串的长度，就需要遍历计算一下才知道，如下图所示

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070830415.png)

串的顺序存储有问题：比如两串的连接(Concat)、新串的插入(StrInsert),以及字符串的替换(Replace),都有可能使得串序列的长度超过了数组的长度MaxSize。

解决串的顺序存储问题的方案：串值的存储空间在执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做堆。这个堆可以由C语言动态分配函数malloc()和free()来管理。

#### 5.5.2 串的链式存储

串的链式存储，一个结点可以存放一个字符，也可以考虑放多个字符，最后一个结点若是未被占满，可以用“#”或其他非串值字符补全，如下

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070837117.png)

但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。

### 5.6 朴素的模式匹配算法

略

### 5.7 KMP模式匹配算法

KMP算法简称克努特-莫里斯-普拉特算法，可以大大避免重复便利的情况。

#### 5.7.1 KMP模式匹配算法的原理

这部分看书

#### 5.7.2 next数组值的推导过程

这部分看书

相关代码

获取子串T的next数组
```c
/* 通过计算返回子串T的next数组 */
void get_next(string T, int *next) {
  int i, k;
  i=1;
  k=0;
  next[1] = 0;
  while (i < T[0]) { /* 此处T[0]表示串的长度 */
    if (k == 0 || T[i] == T[k]) {
      ++i;
      ++k;
      next[i] = k;
    } else {
       k = next[k]; /* 若字符不相同，则k值回溯 */
    }
  }
}
```

KMP算法

```c
int Index_KMP(String S, String T, int pos) {
  int i = pos;
  int j = 1;
  int next[255];
  get_next(T, next);
  while (i <= S[0] && j <= T[0]) {
    if (j == 0 || s[i] == T[j]) 
    {
      ++i;
      ++j;
    } else {
      j = next[j];
    }
  }
  if (j > T[0]) {
    return i - T[0];
  } else {
    return 0;
  }
}
```

上面这段代码的时间复杂度为O(n+m)

#### 5.7.4 KMP模式匹配算法的改进

这部分看书

```
void get_nextval(String T, int *nextval) 
{
  int i, k;
  i = 1;
  k = 0;
  nextval[1] = 0; 

  while (i < T[0]) 
  {
      if (k == 0 || T[i] == T[K]) {
        ++i;
        ++k;
        
        if (T[i] != T[k]) {
          nextval[i] = k;
        } else {
          nextval[i] = nextval[k];
        }
      } else {
        k = nextvak[k];
      }
  }
}
```

#### 5.7.5 nextval数组值的推导

这部分省略，请看书