# 大话数据结构（二）

## 第四章 栈和队列

栈和队列： 栈是限定仅在表尾进行插入和删除操作的线性表。队列是允许在一端进行插入操作，而在另一端进行删除操作的线性表。

### 4.2 栈的定义

> 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

**概念**

- 栈顶：允许插入和删除的一端称之为栈顶。
- 栈底：与栈顶相反
- 空栈：不含任何数据元素的栈称为空栈。
- LIFO结构：是Last In First Out（后进先出）


理解栈的定义需要注意如下几点：
- 它是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系
- 定义中说的是在线性表的表尾进行插入和删除操作，这里的表尾指的是栈顶，而不是栈底

栈的插入操作称为进栈（也称压栈、入栈）
栈的删除操作称为出栈（也称为弹栈）

### 4.3 栈的抽象数据类型

```c
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序存储结构

栈的顺序存储结构用数组实现。以0的那一端作为栈底，另一端为栈顶

栈的结构定义如下

```c
typedef int SElemType;

tupedef struct {
    SElemType data[MAXSIZE];
    int top;                   /* 用于栈顶指针 */
}SqStack;
```

#### 4.4.2 栈的顺序存储结构-进栈操作

代码如下：

```c
Status Push(SqStack *S, SElemType e) 
{
    if (S->top == MAXSIZE - 1)  /* 栈满了 */
    {
        return ERROR;
    }
    S->top++;
    S->data[S->top]=e;
    return OK;
}
```

#### 4.4.3 栈的顺序存储空间-出栈操作

代码如下：

```c
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == -1) {
        return OK;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

### 4.5 两栈共享空间

如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这个时候我们完全可以用一个数组来存储快两个栈，充分利用这个数组占用的内存空间。

做法如下图所示。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标的n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305051832555.png)

从这里分析出，若栈1为空时，top1等于-1；若栈2为空时，top2等于n。

栈满分为三种情况：
- 栈1满：top1=n-1，top2=n
- 栈2满：top1=-1，top2=0
- 栈满：top1+1 = top2

两栈共享空间结构的代码如下：

```c
typedef struct {
    SElemType data[MAXSIZE];
    int top1;
    int top2;
}SqDoubleStack;
```

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要判断时栈1还是栈2的栈号参数stackNumber，插入元素的代码如下：

```c
Status Push(SqDoubleStack *S, SElemType e, int stackNumber) {
    if (S->top1+1 == S->top2) { // 栈满
       return ERROR;
    }
    
    if (stackNumber == 1) { // 栈1
        S->data[++S->top1] = e;
    }
    
    if (stackNumber == 2) { // 栈1
        S->data[--S->top2] = e;
    }
    
    return OK;
}
```

因为在代码开始时已经判断了是否有栈满的情况,所以后面的top1+1或top2是不担心溢出问题的.

对于两栈共享空间pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下

```c
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber) {
    if (stackNumber == 1) {
        if (S->top1 == -1) {
            return ERROR;
        }
        
        *e = S->data[S->top1--];
    } else if (stackNumber == 2) {
         if (S->top1 == MAXSIZE) {
            return ERROR;
        }
        
        *e = S->data[S->top2++];
    }
}
```

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

栈的链式存储，称为链栈。

链栈与链表注意点：
- 栈顶放在链表的头部
- 单链表的头指针和栈顶指针合二为一
- 不需要头结点（累赘）
- 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
- 对于链栈来说，链表原定义式指针指向空，那么链栈的空其实就是top=NULL的时候。

链栈的结构代码如下：

```c
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct 
{
    LinkStackPtr top;
    int count;
}LinkStack;
```

链栈的操作绝大部分和单链表类似，只是插入和删除上，特殊一点。

#### 4.6.2 栈的链式存储结构-进栈操作

代码如下所示

```c
Status Push(LinkStack *S, SElemType e){
    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 栈的链式存储结构-出栈操作

代码如下：

```c
Status Pop(LinkStack *S, SElemType *e) {
    LinkStackPtr p;
    if (StackEmpty(*S)){
        return ERROR;
    }
    *e = S->top->data;
    p = S->top;
    S->top=S->top->next;
    free(p);
    S->count--;
    return OK;
}
```

栈选用顺序存储还是链式存储：如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那就用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好。

### 4.7 栈的作用

栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。

### 4.8 栈的应用-递归

#### 4.8.1 斐波那契数列的实现

代码如下：

```c
int Fbi(int i) 
{
    if (i < 2) {
        return i == 0 ?  0 : 1;
    }
    return Fbi(i-1)+Fbi(i-2);
}

int main() 
{
    int i;
    printf("递归显示斐波那契数列：\n");
    for (i = 0; i < 40; i++) {
        printf("%d ", )
    }
    
    return 0;
}
```

#### 4.8.2 递归的定义

定义：我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数称为递归函数。

> 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

### 4.9 栈的应用-四则运算表达式求值

#### 4.9.1 后缀（逆波兰）表示法定义

定义：一种不需要括号的后缀表达式，我们也把它称为逆波兰（Reverse Polish Notation, RPN）表示。

>例子：
>
> 正常表达式：9+(3-1)*3+10/2
>
> 转换为后缀表达式：9 3 1 - 3 * + 10 2 / + 
> 

#### 4.9.2 后缀表达式的计算结果

后缀表达式：9 3 1 - 3 * + 10 2 / + 

规则：从左往右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

具体流程看书（leetcode有一样的题目）

#### 4.9.3 中缀表达式转后缀表达式

中缀表达式的定义：我们平时所用的标准四则运算表达式，如：“9（3-1）*3+10/2”

那么中缀表达式怎么转换为后缀表达式呢？

规则：从左往右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于（小于等于）栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

具体流程看书（leetcode有一样的题目）

总结：
- 将中缀表达式转化为后缀表达式（栈用来进出运算符号）
- 将后缀表达是进行运算得出运算结果（栈用来进出运算的数字）

### 4.10 队列的定义

定义：队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头

### 4.11 队列的抽象数据类型

同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。

```
ADT 队列
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q。
    DestroyQueue(*Q)：若队列Q存在，则销毁它
    ClearQueue(*Q)：将队列Q清空
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false
    GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素
    EnQueue(*Q, e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素
    DeQueue(*Q, *e)：删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数。
endADT
```

### 4.12 循环队列

具体的最好还是看书比较合适

#### 4.12.1 队列顺序存储的不足

以数组的0为表头，以数组的另一方向为表尾的不足：
- 在表尾插入数据的时间复杂度为O(1)，在表头删除数据的时间复杂度为O(n)
- 为了解决在表头删除的时间复杂度为O(n),引入了两个指针，front指针指向队头元素，rear指向队尾元素的下个元素，如下图所示
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081850726.png)
- 如果表为空则front指针和rear指针指向同一个结点，如下
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081852601.png)
- 那么队列满的时候呢？那么rear就会溢出去？值是什么？不知道
- 看下图，假设这个队列的总个数不超过5个，但是目前如果接着入队，因为数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上队列再下标0和1的地方还是空闲的。这就叫假溢出。
  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305081856265.png)
    

#### 4.12.2 循环队列的定义

为了解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。***我们把队列的这种头尾相接的顺序存储结构称为循环队列***

分析过程请看书

循环队列相关计算
- 队空：front = rear
- 堆满：front = (rear+1)%QueueSize ***(注：这种方式要付出代价，队列一定要有一个元素不能用)***
- 队列长度公式：(rear-front+QueueSize)%QueueSize

循环队列的顺序存储结构代码如下：

```c
typedef int QElemType;

typedef struct
{
  QElemType data[MAXSIZE];
  int front, rear;  
}SqQueue;
```

循环队列的初始化代码如下：
```c
Status InitQueue(SqQueue *Q) 
{
  Q->front = 0;
  Q->front = 0;
  return OK;
}
```

循环队列求队列长度代码如下

```c
int QueueLength(SqQueue Q) 
{
  return (Q->rear-Q->front+MAXSIZE)%MAXSIZE;
}
```

循环队列入队列操作代码如下：

```c
Status EnQueue(SqQueue *Q, QElemType e)
{
  if ((Q->rear+1)%MAXSIZE == Q->front) { // 满了
    return ERROR;
  }
  
  Q->data[Q->rear] = e;
  Q->rear = (Q->rear+1) % MAXSIZE;
  
  return OK;
}
```

循环队列出队列操作代码如下：

```c
Status DeQueue(SqQueue *Q, QElemType *e) {
  if (Q->rear == Q->front) { // 队列是空的
    return ERROR;
  }
  
  *e = Q->data[Q->front];
  Q->front = (Q->front+1)%MAXSIZE;
  
  return OK;
}
```

### 4.13 链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列
- 头指针指向链队列的*头结点*
- 队尾指针指向终端结点
- 空队列时，front和rear都指向头结点。

链队列的结构如下：

```c
typedef int QElemType;

typedef struct QNode 
{
  QElemType data;
  struct QNode *next;
}QNode, *QueuPtr;

typedef struct 
{
  QueuePtr front, rear;
}LinkQueue;
```

#### 4.13.1 队列的链式存储结构-入队操作

入队时，其实就是在链表尾部插入结点，如下所示。

代码如下：

```c
Status Enqueue(LinkQueue *Q, QElemType e) {
  QueuePtr s=(QueuePtr)malloc(size(QNode));
  if (!s) {
    exit(OVERFLOW);
  }
  s->data = e;
  s->next = null;
  Q->rear->next = s;
  Q->rear = s;
}
```


#### 4.13.2 队列的链式存储结构-出队操作

出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素，则需要rear指向头结点。

代码如下：

```c
Status DeQueue(LinkQueue *Q, QElemType *e) {
  QueuePtr p;
  
  if (Q->front == Q->rear){
    return ERROR;
  }
  
  p = Q->front->next;
  *e = p->data;
  Q->front->next = p->next;
  if (Q->rear == p) {
    Q->rear = Q->front;
  }
  
  free(p);
  return OK;
}
```

对于循环队列与链队列的比较，可以从两方面考虑，时间上，其实它们的基本操作都是常数时间，即都为O(1),不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。

总的来说，在可以确定队列长度最大值的情况下，建议使用循环队列，如果你无法预估队列的长度，则用链队列

### 4.14 总结

- 栈和队列都是特殊的线性表，只不过对插入和删除操作做了限制
- 栈是限定仅在表尾进行插入和删除操作的线性表
- 队列是只允许一端进行插入操作，在另一端进行删除操作的线性表
- 它们均可以用线性表的顺序存储结构来实现，但都存在这顺序存储的一些弊端
  - 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端左栈底的方法来让两个栈的共享数据，这就可以最大化利用数组的空间
  - 对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)
- 它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同，如下图所示
![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305091836573.png)

## 第五章 串

### 5.2 串的定义

串：串是由零个或多个字符组成的有限序列，又叫做字符串

概念：

- 串的长度：串中的字符数目n称为串的长度
- 空串：零个字符的串称为空串（null string）。可以直接用双引号“""”表示，也可以用希腊字母“Φ”来表示
- 空格串：是只包含空格的串。空格串是由内容有长度的，而且可以不止一个空格
- 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应的，包含子串的串称为主串
- 子串在主串中的位置就是子串的第一个字符在主串的序号

### 5.3 串的比较

> 计算机中常用字符是发展
> 
> 使用标准的ASCII码，更准确点，由7位二进制数表示一个字符，总共可以表示128个字符
> 
> 扩展ASCII码由8位二进制数表示一个字符，总共可以表示256个字符（能够满足以英语为主的语言和特殊符号，但是不能满足中文）
> 
> Unicode编码，由16位的二进制数表示一个字符，那么就可以表示约6.5万个字符
> 
> 当然，为了和ASCIⅡ码兼容，Unicode的前256个字符与ASCI码完全相同
> 

如果两个串不想等，如何判断他们的大小呢？我们这样定义：

给定两个串：s=“a1, a2,...an”, t="b1,b2,...bm",当满足以下条件之一时s<t

(1) n < m,且ai=bi（i=1,2,...,n）

例如当s=“hap”,t=“happy”,就有s<t。因为t比s多出了两个字母。

(2) 存在某个k<=min(m,n),使得ai=bi(i=1,2,...,k-1), ak<bk

例如当s=“happen”,t=“happy”,因为两串的前4个字母均相同，而两串第5个字 母(k值)，字母e的ASCII码是101，而字母y的ASCII码是121，显然e<y,所以s<t。

### 5.4 串的抽象数类型

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306061914073.png)

### 5.5 串的存储结构

#### 5.5.1 串的顺序存储结构

串的顺序存储结构是一组地址连续的存储单元来存储串中的字符序列的。按照与定义的大小，为每个定义的串的变量分配一个固定长度的存储区。一般用定长数组来定义。

定长数组存储串有两种形式

- 将串的实际长度值存在数组的0下标位置。如下图所示。

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070828560.png)
- 在串值后面加一个不计入串长度的结束标记字符，如“\0”来表示串的终结，这个时候要计算串的长度，就需要遍历计算一下才知道，如下图所示

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070830415.png)

串的顺序存储有问题：比如两串的连接(Concat)、新串的插入(StrInsert),以及字符串的替换(Replace),都有可能使得串序列的长度超过了数组的长度MaxSize。

解决串的顺序存储问题的方案：串值的存储空间在执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做堆。这个堆可以由C语言动态分配函数malloc()和free()来管理。

#### 5.5.2 串的链式存储

串的链式存储，一个结点可以存放一个字符，也可以考虑放多个字符，最后一个结点若是未被占满，可以用“#”或其他非串值字符补全，如下

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306070837117.png)

但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。

### 5.6 朴素的模式匹配算法

略

### 5.7 KMP模式匹配算法

KMP算法简称克努特-莫里斯-普拉特算法，可以大大避免重复便利的情况。

#### 5.7.1 KMP模式匹配算法的原理

这部分看书

#### 5.7.2 next数组值的推导过程

这部分看书

相关代码

获取子串T的next数组
```c
/* 通过计算返回子串T的next数组 */
void get_next(string T, int *next) {
  int i, k;
  i=1;
  k=0;
  next[1] = 0;
  while (i < T[0]) { /* 此处T[0]表示串的长度 */
    if (k == 0 || T[i] == T[k]) {
      ++i;
      ++k;
      next[i] = k;
    } else {
       k = next[k]; /* 若字符不相同，则k值回溯 */
    }
  }
}
```

KMP算法

```c
int Index_KMP(String S, String T, int pos) {
  int i = pos;
  int j = 1;
  int next[255];
  get_next(T, next);
  while (i <= S[0] && j <= T[0]) {
    if (j == 0 || s[i] == T[j]) 
    {
      ++i;
      ++j;
    } else {
      j = next[j];
    }
  }
  if (j > T[0]) {
    return i - T[0];
  } else {
    return 0;
  }
}
```

上面这段代码的时间复杂度为O(n+m)

#### 5.7.4 KMP模式匹配算法的改进

这部分看书

```
void get_nextval(String T, int *nextval) 
{
  int i, k;
  i = 1;
  k = 0;
  nextval[1] = 0; 

  while (i < T[0]) 
  {
      if (k == 0 || T[i] == T[K]) {
        ++i;
        ++k;
        
        if (T[i] != T[k]) {
          nextval[i] = k;
        } else {
          nextval[i] = nextval[k];
        }
      } else {
        k = nextvak[k]; 
      }
  }
}
```

#### 5.7.5 nextval数组值的推导

这部分省略，请看书


## 第六章 树的结构

### 6.2 树的定义

定义： 树是n个节点的有限集。n=0时称为空树。在任意一棵非空树中：①有且仅有一个特定的称为根（Root）的节点；②当n>1时，其余节点可分为m(m>0)个互不交集的有限集T1、T2、...、Tm，其中每个集合本身又是一棵树，并且称为根的子树。如下所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306200906213.png)

对于树的定义还需要强调两点：

- n>0时根结点是唯一的，不可能存在多个根结点
- m>0时，子树的个数没有限制，但他们一定不相交

#### 6.2.1 结点的分类

结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点，树的度是树内各结点度的最大值。如下图所示：这棵树结点的度的最大值是结点D的度，为3，所以树的度也为3

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201832790.png)

#### 6.2.2 结点间的关系

- 结点的子树的根称为该结点的孩子（Child），相应的，该结点称为孩子的双亲（parent）。
- 同一个双亲的孩子之间互称为兄弟（Slibing）。结点的祖先是从根到该结点所经分支的上的所有结点。
- 以某结点为根的子树的任一结点都称为该结点的子孙。

#### 6.2.3 树的其他相关概念

结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或者该度。如下图，当前树的深度为4

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201842467.png)

如果树中结点的各个子树看成从左至右是有次序的，不能互换，则称该树为有序树，否则称为无序树。

森林（Forest）是m（m >= 0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。

对比线性表和树的结构，他们有很大的不同，如下所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201847118.png)

### 6.3 树的抽象数据类型

看书

### 6.4 树的存储结构

树的存储结构表示法有三种：双亲表示法、孩子表示法、孩子兄弟表示法。

#### 6.4.1 双亲表示法

除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲

我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲结点在哪里，它的结点结构如下所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201853614.png)

其中，data是数据域，存储结点的数据信息；parent是指针域，存储该结点的双亲在数组中的下标

以下是我们的双亲表示法的结点结构定义代码：

```c
#define MAX_TREE_SIZE 100

typedef int TElemType;

typedef struct PTNode
{
  TElemType data;                   /* 结点数据 */
  int parent;                       /* 双亲的位置 */
}PTNode;

typedef struct                     /* 树结构 */
{
  PTNode nodes[MAX_TREE_SIZE];    /* 结点数组 */
  int r,n;                        /* 根的位置和结点数 */
}PTree;
```

由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这就意味着，我们所有的结点都存有它双亲的位置。如下图中的树结构可用下表中的树双亲表示。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201906607.png)

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201906234.png)

这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1),直到parent:为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。

我们可以改进一下。增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如下表示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201909045.png)

另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样地，如果右兄弟不存在，则赋值为-1，如下表所示。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306201913609.png)

存储结构的设计是一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。

#### 6.4.2 孩子表示法

由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们吧这种方法叫做多重链表表示法。

- 方案一
  
  一种是指针域的个数等于树的度，复习一下，树的度是树的各个结点度的最大值。其结构如下表示。

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210837963.png)

  其中，data是数据域：child1～childn是指针域，用来指向该结点的孩子结点。

  对于下图左边的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如右下图所示。

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210841778.png)

  这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。

  - 方案二
  
    第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如下表示。

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210844849.png)

    其中，data为数据域：degree为度域，也就是存储该结点的孩子结点的个数；child1～childd为指针域。指向该结点的各个孩子的结点。例子如下

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210846488.png)

    这种方法克服了浪费空间的缺点，对空间的利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。

    能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。仔细观察，我们为了要遍历整棵树。把每个结点放到一个顺序存储结构的数组中是 合理的但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。

    这就是孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存进一个一维数组中。如下

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210855610.png

    为此，设计两种结点结构，一个是孩子链表的孩子结点，如下表示。

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210856099.png)

    其中，child是数据域，用来存储某个结点在表头数组中的下标，next是指针域，用来存储指向某结点的下一个孩子结点的指针

    另一个是表头数组的表头结点，如下：

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210858702.png)

    其中data是数据域存储某结点的数据信息；firstchild是头指针域，存储该结点的孩子链表的头指针

    代码如下：

    ```c
    #define MAX_TRUE_SIZE 100
  
    typedef int TElemType;
  
    typedef struct CTNode         /* 孩子结点 */
    {
      int child;
      struct CTNode *next;
    } *ChildPtr;
  
    typedef struct                /* 表头结点 */
    {
      TElemType data;
      ChildPtr firstchild;
    }CTBox;
  
    typedef struct {
      CTBox nodes[MAX_TRUE_SIZE];
      int r,n;                      /* 根结点的位置和结点数 */
    } CTree;
    ```

  这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。

  但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以的。如右图所示。

  ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306210908120.png)

### 6.4.3 孩子兄弟表示法

在任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

结点结构如下表所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306211826558.png)

其中，data是数据域；firstchild为指针域，存储该结点的第一个孩子结点的存储地址；rightsib是指针域，存储该结点的右兄弟结点的存储地址。

结构定义代码如下：

```c
typedef struct CSNode
{
  TElemType data;
  struct CSNode *firstchild, *rightsib;
}
```

对于下图左边的树来说，这种方法实现的示意图如下所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306211831147.png)

缺点：找不到parent，但是可以增加一个parent指针域来解决

### 6.5 二叉树的定义

二叉树（Binary Tree）是n(n >= 0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

#### 6.5.1 二叉树的特点

二叉树的特点有：

- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者一棵子树都是可以的
- 左子树和右子树是有顺序的，次序不能任意颠倒。
- 即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。如下图，他们是不同的二叉树

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306211857476.png)

二叉树具有以下五种基本形态：

- 空二叉树
- 只有一个根结点
- 根结点只有左子树
- 根结点只有右子树
- 根结点既有左子树又有右子树

思考：如果只有三个结点，那么有几种二叉树？五种，如下图所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306211900086.png)

#### 6.5.2 特殊二叉树

1. 斜树

   所有结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。
  
   斜树有很明显的特征，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。
  
2. 满二叉树

   在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树统称为满二叉树。如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306211910625.png
  
   满二叉树的特点：
   - 叶子只能出现在最下一层。
   - 非叶子结点的度一定是。
   - 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

3. 完全二叉树

    