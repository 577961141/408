# 第五章 树与二叉树

## 5.1 树的基本概念

### 5.1.1 树的定义

树是n(n>=0)个结点的有限集，当n=0时称为空树。在任意一棵非空树中应满足：
- 有且仅有一个特定的称为根的结点
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T(1),T(2),...,T(m)，其中每个集合本身又是一棵树，并且称为根的子树

树是递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：
- 树的根结点没有前驱，除根结点没前驱外树的所有结点有且仅有一个前驱
- 树中所有结点的后继可以有零个或者多个

在n个结点的树中有n-1条边

### 5.1.2 基本术语

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307100848226.png)

- 略
- 略
- 度大于0的结点称为分支结点（又称非终端结点）；度为0（没有子女结点）的结点称为叶结点（又称终端结点）。在分支结点中。每个结点的分支数就是该结点的度。
- 结点的深度、高度和层次
  - 结点的层次从根开始定义，根结点为第1层，它的子结点为第2层
  - 结点的深度是从根结点开始自顶向下逐层累加的
  - 结点的高度是从叶结点开始自底向上逐层累加的
  - 树的高度（或深度）是树中结点的最大层数
- 有序树和无序树。树中结点各个子树从左到右是有序的，不能互换，称该树为有序树，否则为无序树。
- 路径和路径长度。树中两个结点之间的路径是由两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数（注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下同一双亲的两个孩子之间不存在路径。）
- 森林。森林是m（m>=0）棵互不相交的树的集合。森林的概念与树的概念十分接近，因为只要吧树的根结点删除了就变成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树做为该结点的子树，则森林就变成了树。

### 5.1.3 树的性质

- 树中的结点数等于所有结点的度数之和加一
- 度为m的树中第i层上至多有m^(i-1)个结点（i>=1）
- 高度为h的m叉树至多有(m^(h)-1)/(m-1)个结点
- 具有n个结点的m叉树的最小高度为（看书）

### 5.1.4 本节试题精选 

一、单项选择

```
1. D
2. A
3. C(A)
4. A
5. A
6. C
7. B
```

## 5.2 二叉树的概念

### 5.2.1 二叉树的定义及其主要特性

1. 二叉树的定义

    二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

    与树相似，二叉树也是以递归的形式定义，二叉树是由n（n>=0）个有限结点组称的集合
    - 二叉树可以为空树，即n=0
    - 二叉树可以由一个根结点和两个互不相交的称为根的左子树和右子树组成，左子树和右子树又分别是一棵二叉树。

    二叉树是有序树，其左右子树如果颠倒，就不再是原来的二叉树。即使树中结点只有一棵树，也要区分是左子树还是右子树，如下图，二叉树的五种形态。

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130818921.png)

    二叉树与度为2的有序树的区别：

   - 度为2的有序树至少有三个结点，而二叉树可以为空树
   - 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，如果某个结点只有一个孩子，那么就不用区分左右次序。而二叉树不管其孩子数是否为2，均需要确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。

2. 几个特殊的树

   - 满二叉树。一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点，如下图所示
     ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130842173.png)
  
     满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2。

     若对满二叉树进行编号，从上往下，从左往右，如果某个结点的编号为i，如果这个结点有双亲，那么这个双亲的编号为i/2（向下取整），其左孩子编号为2i，右孩子编号为2i+1
   - 完全二叉树。高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树，如下图所示。其特点如下：

     ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130853397.png)

     - 若i<=n/2(向下取整)，则结点i为分支结点，否则为叶结点
     - 叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排在该层最左边位置上。
     - 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子
     - 按照层序编号后，如果某个结点i为叶子结点或者只有左子树的结点，那么大于i的编号结点，都为叶结点
     - 如果n为奇数，则每个分支结点都有左右孩子；若n为偶数，则编号最大的分支结点（编号n/2）只有左孩子，没有右孩子，其余分支结点左右孩子都有

   - 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。
   - 平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1。
3. 二叉树的性质
   - 非空二叉树的叶子结点数等于度为2的结点数+1。（证明过程看书）
   - 非空二叉树上第k层至多有2^(k-1)个结点
   - 高度为h的二叉树至多有2^h-1个结点（h>=1）
   - 对完全二叉树按从上到下、从左往右的顺序依次编号1，2，...，n，则有以下关系
     - 当i>1时，结点i的双亲编号为i/2（向下取整），即当结点i为偶数时，其双亲编号为i/2，结点i是其左孩子，当结点i为奇数时，其双亲编号为(i-1)/2，结点i是其右孩子
     - 当2i<=n时，结点i的左孩子编号为2i，否则无左孩子
     - 当2i+1<=n时，结点i的右孩子编号为2i+1，否则无右孩子
     - 结点i所在层次（深度）为log2i（向下取整）+1
   - 具有n个(n>0)结点的完全二叉树的高度为log2（n+1）（向上取整）或log2n（向下取整）+1（证明过程看书）

### 5.2.2 二叉树的存储结构

1. 顺序存储结构

    二叉树的顺序存储就是用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上的编号为i的结点元素存储在一维数组下标为i-1的分量中

    依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系

    但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对应，再存储到一维数组的相应分量中。然而，再最坏的情况下，一个高度h且只有h个结点的单支树却需要占据近`2^h-1`个存储单元

    注意：这种存储结构建议从下标1开始存储树中的结点，若从数组下标0开始存储，则不满足性质4的描述
2. 链式存储结构

    由于顺序存储的空间利用率比较低，因此二叉树一般采用链式存储结构。在二叉树中，结点结构通常是若干个数据域和若干个指针域，二叉链表至少包含3个域：数据域data、左指针域lchild、右指针域rchild。如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307170851008.png)。

    下图为二叉链表的存储结构

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307170854239.png)

    还可以增加一些指针域，如指向父节点的指针域，变为了三叉链表的存储结构。

    二叉树的链式存储结构描述如下：

    ```
        typedef struct BiTNode {
             ElemType  data;
             struct BiTNode *lchild, *rchild;
        }BiTNode, *BiTree;
    ```
   
    *在n个结点的二叉链表中，含有n+1个空域链*（重要结论）

### 5.2.3 本节试题精选

一、单项选择

```
1. C
2. A
3. B
4. D(B)
5. C
6. C
7. C
8. B(C)
9. C
10. A
11. A
12. D
13. C
14. B
15. B
16. A
17. C
18. D
19. D(C)
20. C
21. A
22. B(A)
```

二、 综合应用题

1. 在非空二叉树中，由度为0和度为2的结点之间的关系n0 = n2 + 1，可知n2 = n0 - 1。因此总结点数 n = n0+n1+n2=2n0+n1-1.（后半部分的解释看书）
2. 在满二叉树中，n1=0，由二叉树的性质1可知n0=n2+1,那么n2=n0-1，二叉树的结点数n=n0+n1+n2，那么叶子结点数为n0+n0-1=n-0，即叶子结点数为n0=(n+1)/2,分支结点数为n2=n-(n+1)/2=(n-1)/2.高度为h的满二叉树的结点数n=2^h-1,即高度为h=log2(n+1)
3. 在完全二叉树中，如果第9层是满的，那么结点数为2^(9-1)=256个，而题目中说第9层结点数是240个，说明第9层未满，是最后一层，那么前面8层都是满的，前面8层的结点数为2^8-1,那么总结点数为240+2^8-1=495.

    因为第九层是最后一层，所以第九层的240个结点都是叶结点，那么第8层的结点中就有120个是度为2的分支结点，而第8层的结点数为2^(8-1)=128个结点，即有8个结点是叶结点，所以总的叶结点数为8+240=248（另一种解法，n=n0+n1+n2，而n2=n0-1，那么n=2n0+n1-1，即495=2n0+n1-1，如果度为1的结点有1个，即n1=1，那么2n0=495，不符合；如果度为1的结点有0个，即n1=0，那么2n0=496，即n0=248）
4. 
    - 第一层有m^0=1个结点,第二层有m^1个结点，第三层有m^2个结点......那么第i层有m^(i-1)个结点（1<=i<=i）
    - 在m叉数的情形下，结点i的第1个子女编号为j=(i-1)*m+2,反过来，结点i的双亲的编号是(i-2)/m(向下取整)+1，根结点没有双亲，所以要求i>1
    - 因为结点i的第1个子女编号为(i-1)m+2,若设该结点子女的序号为k=1，2，...，m，则第k个子女结点的编号为(i-1)m+k+1(1<=k<=m)
    - 看书
5. 看书

## 5.3 二叉树的遍历和线索二叉树

### 5.3.1 二叉树的遍历

二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。

按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序(NLR)、中序(LNR)和后序(LRN)三种遍历算法，其中“序”指的是根结点再何时被访问。

1. 先序遍历

    递归算法如下：

    ```
    void PreOrder(BiTree T) {
        if (T != NULL) {
            visit(T);               // 访问根结点
            PreOrder(T->lchild);    // 访问左子树
            PreOrder(T->rchild);    // 访问右子树
        }
    }
    ```

2. 中序遍历

   递归算法如下：

    ```
    void PreOrder(BiTree T) {
        if (T != NULL) {
            PreOrder(T->lchild);    // 访问左子树
            visit(T);               // 访问根结点
            PreOrder(T->rchild);    // 访问右子树
        }
    }
    ```

3. 后序遍历

   递归算法如下：

    ```
    void PostOrder(BiTree T) {
        if (T != NULL) {
            PreOrder(T->lchild);    // 访问左子树
            PreOrder(T->rchild);    // 访问右子树
            visit(T);               // 访问根结点
        }
    }
    ```
   
    上面三种算法的时间复杂度为O(n)，空间复杂度也为O(n)
4. 递归算法和非递归算法

    在上节介绍的三种遍历算法中，暂时抹去和递归无关的visit()语句，则三个遍历算法完全相同，因此，从递归执行过程的角度看先序、中序和后续是完全相同的。

    中序遍历分析过程：略（看书）

    中序遍历非递归代码如下：

    ```
     void InOrder2(BiTree T) {
         InitStack(S); 
         BiTree p = T;
         while(p || !IsEmpty(S)) {
            if (p) {
                Push(S, p);
                p = p->lchild;
            } else {
                Pop(S, p);
                visit(p);
                p = p->rchild;
            }
         }
     }
    ```
   
    前序遍历非递归代码如下：

    ```
     void PreOrder2(BiTree T) {
        InitStack(S);
        BiTree p = T;
        while(p || !IsEmpty(S)) {
            if (p) {
                visit(p);
                Push(S, p);
                p = p->lchild;
            } else {
                Pop(S, p);
                p = p->rchild;
            }
        }
     }
    ```
   
    后序遍历非递归代码如下：

    ```
        
    ```

5. 层序遍历

    解释看书

    代码如下：

    ```
        void LevelOrder(BiTree T) {
            InitQueue(Q);
            BiTree p;
            EnQueue(Q, T);
            while(!IsEmpty(Q)) {
                DeQueue(Q, p);
                visit(p);
                if (p->lchild != NULL) {
                    EnQueue(Q, p->lchild);
                }
   
                if (p->rchild != NULL) {
                    EnQueue(Q, p->rchild);
                }
            }
        }
    ```
   
6. 由遍历序列构造二叉树 

    由二叉树的先序序列和中序序列可以唯一确定一棵二叉树。
   
    在先序遍历中，第一个结点一定是二叉树的结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能确定这棵二叉树。

    由二叉树的后序序列和中序序列也可以唯一确定一棵二叉树。

    因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。

    由二叉树的层序序列和中序序列也可以唯一确定一棵二叉树。（过程略）

    例如，求先序序列(ABCDEFGHI)和中序序列（BCAEDGHFI)所确定的二叉树。 首先，由先序序列可知A为二叉树的根结点。中序序列中A之前的'BC为左子树的中序序列， EDGHFI为右子树的中序序列。然后，由先序序列可知B是左子树的根结点，D是右子树的根结 点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如图所示。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307210906551.png)

### 5.3.2 线索二叉树

1. 线索二叉树的基本概念

    传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含有n个结点的二叉树中，有n+1个空指针。这是因为每个叶结点都有两个空指针，每个度为1的结点都有一个空指针，空指针总数为2n0+n1，又n0=n2+1，所以空指针总数为n0+n1+n2+1 = n+1。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。

    规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。如下图所示，还需要增加两个标志域指示指针域，以指向左（右）孩子或前驱（后继）

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307211904089.png)

    其中，标志域的含义如下：

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307211905733.png)

    线索二叉树的存储结构描述如下：

    ```
        typedef struct ThreadNode {
            ElemType data;
            struct ThreadNode *lchild,*child;
            int ltag,rtag;
        }ThreadNode, *ThreadTree;
    ```

   以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱和后继的指针称为线索。加上线索的二叉树称为线索二叉树。
2. 中序线索二叉树的构造

    二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。

    以中序线索二叉树的建立为例子。附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307220850846.png)

    通过中序遍历对二叉树线索化的递归算法如下：

    ```
        void InThread(ThreadTree &p, ThreadTree &pre) {
            if (p != NULL) {
                InThread(p->lchild, pre);
                if (p->lchild == NULL) {
                    p->lchild = pre;
                    p->ltag = 1;
                }
   
                if (pre != NULL && pre->rchild == NULL) {
                    pre->rchild = p;
                    pre->rtag = 1;
                }
     
                pre = p;
                InThread(p->rchild, pre);
            }
        }
    ```
   
    通过中序遍历建立中序线索二叉树的主过程如下：

    ```
        void CreateInThread(ThreadTree T) {
            ThreadTree pre = NULL;
   
            if (T != NULL) {
                InThread(T, pre);
                pre->rchild = NULL;
                pre->rtag = 1;
            }
        }
    ```
   
   为了方便，可以在二叉树的线索链表上添加一个头结点，令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点的rchild域指针均指向头结点。这就好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307230840639.png)

3. 中序线索二叉树的遍历

   中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在线索二叉树中找结点后继规律是：其右标志为“1”，则右链为线索，只是其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下：

   - 求中序线索二叉树中中序序列的第一个结点
   
   ```
      ThreadNode *Firstnode(ThreadNode *p) {
         while (p->ltag == 0) p = p->lchild; // 最左下结点（不一定是叶结点）
         return p;
      }
   ```
   
   - 求中序线索二叉树中结点p在中序序列下的后继
   
   ```
      ThreadNode *Nextnode(ThreadNode *p) {
         if (p->rtag == 0) return Firstnode(p->rchild);
         else return p->rchild;
      }
   ```
   
   那么怎么获取中序线索二叉树最后一个结点和结点p前驱的计算呢？

   将函数1中的ltag和lchild换成rtag和rchild，即为求中序线索二叉树的最后一个结点。将函数2中的rtag和rchild换成ltag和lchild，此外调用函数改为求中序线索二叉树的最后一个结点，即为求中序线索二叉树中结点p的前驱

   - 利用上面两个算法，可以写出不含头结点的中序线索二叉树的遍历的算法：

   ```
      void Inorder(ThreadNode *T) {
         for (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) {
            visit(p);
         }
      }
   ```

4. 先序线索二叉树和后序线索二叉树

   详细请看书

### 5.3.3 本节试题精选

一、 选择题

1. C
2. C
3. C
4. D(和C的答案有些混淆)
5. A
6. C