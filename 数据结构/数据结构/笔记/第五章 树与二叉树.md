# 第五章 树与二叉树

## 5.1 树的基本概念

### 5.1.1 树的定义

树是n(n>=0)个结点的有限集，当n=0时称为空树。在任意一棵非空树中应满足：
- 有且仅有一个特定的称为根的结点
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T(1),T(2),...,T(m)，其中每个集合本身又是一棵树，并且称为根的子树

树是递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：
- 树的根结点没有前驱，除根结点没前驱外树的所有结点有且仅有一个前驱
- 树中所有结点的后继可以有零个或者多个

在n个结点的树中有n-1条边

### 5.1.2 基本术语

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307100848226.png)

- 略
- 略
- 度大于0的结点称为分支结点（又称非终端结点）；度为0（没有子女结点）的结点称为叶结点（又称终端结点）。在分支结点中。每个结点的分支数就是该结点的度。
- 结点的深度、高度和层次
  - 结点的层次从根开始定义，根结点为第1层，它的子结点为第2层
  - 结点的深度是从根结点开始自顶向下逐层累加的
  - 结点的高度是从叶结点开始自底向上逐层累加的
  - 树的高度（或深度）是树中结点的最大层数
- 有序树和无序树。树中结点各个子树从左到右是有序的，不能互换，称该树为有序树，否则为无序树。
- 路径和路径长度。树中两个结点之间的路径是由两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数（注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下同一双亲的两个孩子之间不存在路径。）
- 森林。森林是m（m>=0）棵互不相交的树的集合。森林的概念与树的概念十分接近，因为只要吧树的根结点删除了就变成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树做为该结点的子树，则森林就变成了树。

### 5.1.3 树的性质

- 树中的结点数等于所有结点的度数之和加一
- 度为m的树中第i层上至多有m^(i-1)个结点（i>=1）
- 高度为h的m叉树至多有(m^(h)-1)/(m-1)个结点
- 具有n个结点的m叉树的最小高度为（看书）

### 5.1.4 本节试题精选 

一、单项选择

```
1. D
2. A
3. C(A)
4. A
5. A
6. C
7. B
```

## 5.2 二叉树的概念

### 5.2.1 二叉树的定义及其主要特性

1. 二叉树的定义

    二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

    与树相似，二叉树也是以递归的形式定义，二叉树是由n（n>=0）个有限结点组称的集合
    - 二叉树可以为空树，即n=0
    - 二叉树可以由一个根结点和两个互不相交的称为根的左子树和右子树组成，左子树和右子树又分别是一棵二叉树。

    二叉树是有序树，其左右子树如果颠倒，就不再是原来的二叉树。即使树中结点只有一棵树，也要区分是左子树还是右子树，如下图，二叉树的五种形态。

    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130818921.png)

    二叉树与度为2的有序树的区别：

   - 度为2的有序树至少有三个结点，而二叉树可以为空树
   - 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，如果某个结点只有一个孩子，那么就不用区分左右次序。而二叉树不管其孩子数是否为2，均需要确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。

2. 几个特殊的树

   - 满二叉树。一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点，如下图所示
     ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130842173.png)
  
     满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2。

     若对满二叉树进行编号，从上往下，从左往右，如果某个结点的编号为i，如果这个结点有双亲，那么这个双亲的编号为i/2（向下取整），其左孩子编号为2i，右孩子编号为2i+1
   - 完全二叉树。高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树，如下图所示。其特点如下：

     ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307130853397.png)

     - 若i<=n/2(向下取整)，则结点i为分支结点，否则为叶结点
     - 叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排在该层最左边位置上。
     - 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子
     - 按照层序编号后，如果某个结点i为叶子结点或者只有左子树的结点，那么大于i的编号结点，都为叶结点
     - 如果n为奇数，则每个分支结点都有左右孩子；若n为偶数，则编号最大的分支结点（编号n/2）只有左孩子，没有右孩子，其余分支结点左右孩子都有

   - 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。
   - 平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1。
3. 二叉树的性质
   - 非空二叉树的叶子结点数等于度为2的结点数+1。（证明过程看书）
   - 非空二叉树上第k层至多有2^(k-1)个结点
   - 高度为h的二叉树至多有2^h-1个结点（h>=1）
   - 对完全二叉树按从上到下、从左往右的顺序依次编号1，2，...，n，则有以下关系
     - 当i>1时，结点i的双亲编号为i/2（向下取整），即当结点i为偶数时，其双亲编号为i/2，结点i是其左孩子，当结点i为奇数时，其双亲编号为(i-1)/2，结点i是其右孩子
     - 当2i<=n时，结点i的左孩子编号为2i，否则无左孩子
     - 当2i+1<=n时，结点i的右孩子编号为2i+1，否则无右孩子
     - 结点i所在层次（深度）为log2i（向下取整）+1
   - 具有n个(n>0)结点的完全二叉树的高度为log2（n+1）（向上取整）或log2n（向下取整）+1（证明过程看书）

### 5.2.2 二叉树的存储结构

1. 顺序存储结构

    二叉树的顺序存储就是用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上的编号为i的结点元素存储在一维数组下标为i-1的分量中

    依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系

    但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对应，再存储到一维数组的相应分量中。然而，再最坏的情况下，一个高度h且只有h个结点的单支树却需要占据近`2^h-1`个存储单元

    注意：这种存储结构建议从下标1开始存储树中的结点，若从数组下标0开始存储，则不满足性质4的描述
2. 链式存储结构

    由于顺序存储的空间利用率比较低，因此二叉树一般采用链式存储结构。在二叉树中，结点结构通常是若干个数据域和若干个指针域，二叉链表至少包含3个域：数据域data、左指针域lchild、右指针域rchild。如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307170851008.png)。

    下图为二叉链表的存储结构

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307170854239.png)

    还可以增加一些指针域，如指向父节点的指针域，变为了三叉链表的存储结构。

    二叉树的链式存储结构描述如下：

    ```
        typedef struct BiTNode {
             ElemType  data;
             struct BiTNode *lchild, *rchild;
        }BiTNode, *BiTree;
    ```
   
    *在n个结点的二叉链表中，含有n+1个空域链*（重要结论）

### 5.2.3 本节试题精选

一、单项选择

```
1. C
2. A
3. B
4. D(B)
5. C
6. C
7. C
8. B(C)
9. C
10. A
11. A
12. D
13. C
14. B
15. B
16. A
17. C
18. D
19. D(C)
20. C
21. A
22. B(A)
```

二、 综合应用题

1. 在非空二叉树中，由度为0和度为2的结点之间的关系n0 = n2 + 1，可知n2 = n0 - 1。因此总结点数 n = n0+n1+n2=2n0+n1-1.（后半部分的解释看书）
2. 在满二叉树中，n1=0，由二叉树的性质1可知n0=n2+1,那么n2=n0-1，二叉树的结点数n=n0+n1+n2，那么叶子结点数为n0+n0-1=n-0，即叶子结点数为n0=(n+1)/2,分支结点数为n2=n-(n+1)/2=(n-1)/2.高度为h的满二叉树的结点数n=2^h-1,即高度为h=log2(n+1)
3. 在完全二叉树中，如果第9层是满的，那么结点数为2^(9-1)=256个，而题目中说第9层结点数是240个，说明第9层未满，是最后一层，那么前面8层都是满的，前面8层的结点数为2^8-1,那么总结点数为240+2^8-1=495.

    因为第九层是最后一层，所以第九层的240个结点都是叶结点，那么第8层的结点中就有120个是度为2的分支结点，而第8层的结点数为2^(8-1)=128个结点，即有8个结点是叶结点，所以总的叶结点数为8+240=248（另一种解法，n=n0+n1+n2，而n2=n0-1，那么n=2n0+n1-1，即495=2n0+n1-1，如果度为1的结点有1个，即n1=1，那么2n0=495，不符合；如果度为1的结点有0个，即n1=0，那么2n0=496，即n0=248）
4. 
    - 第一层有m^0=1个结点,第二层有m^1个结点，第三层有m^2个结点......那么第i层有m^(i-1)个结点（1<=i<=i）
    - 在m叉数的情形下，结点i的第1个子女编号为j=(i-1)*m+2,反过来，结点i的双亲的编号是(i-2)/m(向下取整)+1，根结点没有双亲，所以要求i>1
    - 因为结点i的第1个子女编号为(i-1)m+2,若设该结点子女的序号为k=1，2，...，m，则第k个子女结点的编号为(i-1)m+k+1(1<=k<=m)
    - 看书
5. 看书

## 5.3 二叉树的遍历和线索二叉树

### 5.3.1 二叉树的遍历

二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。

按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序(NLR)、中序(LNR)和后序(LRN)三种遍历算法，其中“序”指的是根结点再何时被访问。

1. 先序遍历

    递归算法如下：

    ```
    void PreOrder(BiTree T) {
        if (T != NULL) {
            visit(T);               // 访问根结点
            PreOrder(T->lchild);    // 访问左子树
            PreOrder(T->rchild);    // 访问右子树
        }
    }
    ```

2. 中序遍历

   递归算法如下：

    ```
    void PreOrder(BiTree T) {
        if (T != NULL) {
            PreOrder(T->lchild);    // 访问左子树
            visit(T);               // 访问根结点
            PreOrder(T->rchild);    // 访问右子树
        }
    }
    ```

3. 后序遍历

   递归算法如下：

    ```
    void PostOrder(BiTree T) {
        if (T != NULL) {
            PreOrder(T->lchild);    // 访问左子树
            PreOrder(T->rchild);    // 访问右子树
            visit(T);               // 访问根结点
        }
    }
    ```
   
    上面三种算法的时间复杂度为O(n)，空间复杂度也为O(n)
4. 递归算法和非递归算法

    在上节介绍的三种遍历算法中，暂时抹去和递归无关的visit()语句，则三个遍历算法完全相同，因此，从递归执行过程的角度看先序、中序和后续是完全相同的。

    中序遍历分析过程：略（看书）

    中序遍历非递归代码如下：

    ```
     void InOrder2(BiTree T) {
         InitStack(S); 
         BiTree p = T;
         while(p || !IsEmpty(S)) {
            if (p) {
                Push(S, p);
                p = p->lchild;
            } else {
                Pop(S, p);
                visit(p);
                p = p->rchild;
            }
         }
     }
    ```
   
    前序遍历非递归代码如下：

    ```
     void PreOrder2(BiTree T) {
        InitStack(S);
        BiTree p = T;
        while(p || !IsEmpty(S)) {
            if (p) {
                visit(p);
                Push(S, p);
                p = p->lchild;
            } else {
                Pop(S, p);
                p = p->rchild;
            }
        }
     }
    ```
   
    后序遍历非递归代码如下：

    ```
        
    ```

5. 层序遍历

    解释看书

    代码如下：

    ```
        void LevelOrder(BiTree T) {
            InitQueue(Q);
            BiTree p;
            EnQueue(Q, T);
            while(!IsEmpty(Q)) {
                DeQueue(Q, p);
                visit(p);
                if (p->lchild != NULL) {
                    EnQueue(Q, p->lchild);
                }
   
                if (p->rchild != NULL) {
                    EnQueue(Q, p->rchild);
                }
            }
        }
    ```
   
6. 由遍历序列构造二叉树 

    由二叉树的先序序列和中序序列可以唯一确定一棵二叉树。
   
    在先序遍历中，第一个结点一定是二叉树的结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能确定这棵二叉树。

    由二叉树的后序序列和中序序列也可以唯一确定一棵二叉树。

    因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。

    由二叉树的层序序列和中序序列也可以唯一确定一棵二叉树。（过程略）

    例如，求先序序列(ABCDEFGHI)和中序序列（BCAEDGHFI)所确定的二叉树。 首先，由先序序列可知A为二叉树的根结点。中序序列中A之前的'BC为左子树的中序序列， EDGHFI为右子树的中序序列。然后，由先序序列可知B是左子树的根结点，D是右子树的根结 点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如图所示。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307210906551.png)

### 5.3.2 线索二叉树

1. 线索二叉树的基本概念

    传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含有n个结点的二叉树中，有n+1个空指针。这是因为每个叶结点都有两个空指针，每个度为1的结点都有一个空指针，空指针总数为2n0+n1，又n0=n2+1，所以空指针总数为n0+n1+n2+1 = n+1。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。

    规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。如下图所示，还需要增加两个标志域指示指针域，以指向左（右）孩子或前驱（后继）

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307211904089.png)

    其中，标志域的含义如下：

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307211905733.png)

    线索二叉树的存储结构描述如下：

    ```
        typedef struct ThreadNode {
            ElemType data;
            struct ThreadNode *lchild,*child;
            int ltag,rtag;
        }ThreadNode, *ThreadTree;
    ```

   以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱和后继的指针称为线索。加上线索的二叉树称为线索二叉树。
2. 中序线索二叉树的构造

    二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。

    以中序线索二叉树的建立为例子。附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307220850846.png)

    通过中序遍历对二叉树线索化的递归算法如下：

    ```
        void InThread(ThreadTree &p, ThreadTree &pre) {
            if (p != NULL) {
                InThread(p->lchild, pre);
                if (p->lchild == NULL) {
                    p->lchild = pre;
                    p->ltag = 1;
                }
   
                if (pre != NULL && pre->rchild == NULL) {
                    pre->rchild = p;
                    pre->rtag = 1;
                }
     
                pre = p;
                InThread(p->rchild, pre);
            }
        }
    ```
   
    通过中序遍历建立中序线索二叉树的主过程如下：

    ```
        void CreateInThread(ThreadTree T) {
            ThreadTree pre = NULL;
   
            if (T != NULL) {
                InThread(T, pre);
                pre->rchild = NULL;
                pre->rtag = 1;
            }
        }
    ```
   
   为了方便，可以在二叉树的线索链表上添加一个头结点，令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点的rchild域指针均指向头结点。这就好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202307230840639.png)

3. 中序线索二叉树的遍历

   中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在线索二叉树中找结点后继规律是：其右标志为“1”，则右链为线索，只是其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下：

   - 求中序线索二叉树中中序序列的第一个结点
   
   ```
      ThreadNode *Firstnode(ThreadNode *p) {
         while (p->ltag == 0) p = p->lchild; // 最左下结点（不一定是叶结点）
         return p;
      }
   ```
   
   - 求中序线索二叉树中结点p在中序序列下的后继
   
   ```
      ThreadNode *Nextnode(ThreadNode *p) {
         if (p->rtag == 0) return Firstnode(p->rchild);
         else return p->rchild;
      }
   ```
   
   那么怎么获取中序线索二叉树最后一个结点和结点p前驱的计算呢？

   将函数1中的ltag和lchild换成rtag和rchild，即为求中序线索二叉树的最后一个结点。将函数2中的rtag和rchild换成ltag和lchild，此外调用函数改为求中序线索二叉树的最后一个结点，即为求中序线索二叉树中结点p的前驱

   - 利用上面两个算法，可以写出不含头结点的中序线索二叉树的遍历的算法：

   ```
      void Inorder(ThreadNode *T) {
         for (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) {
            visit(p);
         }
      }
   ```

4. 先序线索二叉树和后序线索二叉树

   详细请看书

### 5.3.3 本节试题精选

一、 选择题

1. C
2. C
3. C
4. D(和C的答案有些混淆)
5. A(C)
6. C(B)
7. B(C)
8. C(D)
9. C
10. C
11. B(C)
12. B
13. D
14. D
15. A
16. B
17. A
18. A(C)
19. C
20. C
21. D
22. B(D) 不理解
23. C(D) 不理解
24. D(C)
25. D(C)
26. B
27. D
28. D
29. C
30. A
31. B(A)
32. D
33. D(B)(有一个公式没理解)
34. B
35. A(B)
36. D(B)

二、综合应用题

1. 二叉树的先序序列是NLR,后序序列是LRN。要使NLR=NRL(后序序列反序)成立，L或R应为空，这样的二叉树每层只有一个结点，即二叉树的形态是其高度等于结点个数。以3个结点a，b，c为例，其形态如下图所示。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308090849385.png)
2. 二叉树的先序序列是NLR,后序序列是LRN.要使NLR=LRN成立，L和R应均为空，所以满足条件的二叉树只有一个根结点。
3. 算法思想：后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。结合图5.7来分析：1.沿着根的左孩子，依次入栈，直到左孩子为空。此时栈内元素依次为A B D。2.读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1；否则栈顶元素出栈并访问。栈顶D的右孩子为空，出战并访问，它是后序序列的第一个结点；栈顶B的右孩子不为空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不为空但已被访问，B出栈并访问,栈顶A的右孩子不为空且未别访问过，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不为空但已被访问，a出栈并访问。由此得到后修序列DEBCA

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308100854830.png)

   在上述思想的第2步中，必须分清返回时从左子树返回还是右子树返回的，因此设定一个辅助指针r，用于指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问过。

   ```
      void PostOrder(BiTree T) {
         Init(S);
         BiTode *p = T;
         BiTode *r = NULL;
   
         while (p || !IsEmpty(S)) {
            if (p) {                                 // 走到最左边
               push(S, p);
               p = p->lchild;
            } else {                                 // 向右
               GetTop(S, p);                         // 读栈顶元素（非出栈）
               if (p->rchild && p->rchild != r) {    // 若右子树存在，且未被访问过
                  p = p->rchild;                     // 转向右
               } else {                              // 否则，弹出结点并访问
                  pop(S, p);                         // 将结点弹出
                  visit(p->Ldara);                   // 访问该结点
                  r = p;                             // 记录最近访问过的几点
                  p = NULL;                          // 结点访问完后，重置p指针
               }
            }
         }
      }
   ```
   
   注意：每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需要将p置NULL
4. 一般的二叉树层次遍历是从上而下、从左到右，这里的遍历顺序恰好相反。算法思想：利用原有的层次遍历算法，出队的同时将各结点指针入栈，在所有结点入栈后再从栈顶开始一次访问即为所求的算法。具体实现如下：
   - 把根结点入队列
   - 把一个元素出队列，遍历这个元素
   - 依次把这个元素的左孩子、右孩子入队列
   - 若队列不为空，则跳到2，否则结束
   
   算法如下：

   ```
      void InvertLevel(BiTree bt) {
         Stack S; Queue Q;
         if (bt != NULL) {
            InitStack(S);
            InitQueue(Q);
            EnQueue(Q, bt);
            while(IsEmpty(Q) == false) {
               DeQueue(Q, p);
               Push(S, p);
               if (p->lchid) {
                  EnQueue(Q, p->lchid);
               }
               if (p->rchild) {
                  EnQueue(Q, r->rchid);
               }
            }
   
            while(IsEmpty(S) == false) {
               Pop(s, p);
               visit(p->data);
            }
         }
      }   
   ```
5. 采用层次遍历的算法，设置变量level记录当前结点所在层数，设置变量last指向当前层的最右结点，每次层序遍历出队列时与last指针比较，若两者相等，则层数加一，并让last指向下一层的最右结点，直到遍历完成。level的值即为二叉树的高度。

   算法实现如下：

   ```c++
      int Btdepath(BiTree T) {
         if (!T) {
            return 0;                  // 树空，高度为0
         }
   
         int front = -1, rear = -1;    
         int last = 0, level = 0;      // last指向当前层的最右层
         BiTree Q[MaxSize];            // 设置队列Q，元素时二叉树结点指针且容量足够
         Q[++rear] = T;                // 将根结点入队
         BiTree p;          
         while (front < rear) {        // 队不空，则循环
            p = Q[++front];            // 队列元素出队列，即正在访问的结点
            if (p->lchild) {
               Q[++rear] = p->lchild;
            }
            if (p->rchild) {
               Q[++rear] = p->rchild;
            }
            if front == last {          // 处理该层的最右结点
               level++;
               last = rear;
            }
         }
         return level;
      }
   ```
   
   求某层的结点个数、每层的结点个数、树的最大宽度等，都可采用与此题类似的思想。当然，此题也可以编写为递归算法，如下：

   ```c++
      int Btdepath2(BiTree T) {
         if (T == NULL) {
            return 0;
         }
   
         ldep = Btdepath2(T->lchild);
         rdep = Btdepath2(T->rchild);
   
         if (ldep > rdep) {
            return ldep+1;
         } else {
            return rdep+1;
         }
      }
   ```
   
6. 由先序序列和中序序列可以唯一确定一棵二叉树。算法实现步骤如下。
   - 根据先序序列确定树的根结点。
   - 根据根结点在中序序列中划分出二叉树的左、右子树包含哪些结点，然后根据左、右子树结点在先序序列中的次序确定子树的根结点，即回到步骤1.

   如此重复上述步骤，知道每棵子树仅有一个结点（该子树的根结点）为止，如下图所示：

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308141852399.png)

   算法实现如下：

   ```c++
      BiTree PreInCreat(ElemType A[], ElemType B[]， int l1， int h1, int l2, inth2) {
         //11,h1为先序的第一和最后一个结点下标，12，h2为中序的第一和最后一个结点下标
         //初始调用时，11=12=1，h1=h2=n
         root = (BiTNode*)malloc(sizeof(BiTNode));
         root->data = A[l1];
         for (i = l2; B[i] != root->data; i++);                      // 根结点在中序序列中的划分位置
         llen = i-l2;                                                // 左子树的长度
         rlen = h2 - i;                                              // 右子树的长度
         if (llen) {
            root->lchild = PreInCreat(A, B, l1+1, l1+len, l2, l2+len-1);
         } else {
             root->lchild = NULL;
         }
   
         if (rlen) {
            root->rchild = PreInCreat(A, B, h1-rlen+1, h1, h2-rlen+1, h2);
         } else {
            root->rchild = NULL;
         }
   
         return root;
      }
   ```
   
7. 根据完全二叉树的定义，具有n个结点的完全二叉树与满二叉树中编号从1～n的结点一一对应。算法思想：采用层序遍历，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。

   算法实现如下：

   ```c++
      InitQueue(Q);
      if (!T) {
         return 1;
      }
      EnQueue(Q, T);
      while(!IsEmpty(Q)) {
         DeQueue(Q, p);
         if (p) {
            EnQueue(Q, p->lchild);
            EnQueue(Q, p->rchild);
         } else {
            while(!IsEmpty(Q)) {
               DeQueue(Q, p);
               if (p) {
                  return 0;
               }
            }
         }
      }
   ```

8. 计算一棵二叉树b中所有双分支结点个数的递归模型f(b)如下所示：

   - f(b) = 0;                               若b=NULL;
   - f(b) = f(b->lchild)+f(b->rchild)+1;     若*b为双分支结点
   - f(b) = f(b->lchild)+f(b->rchild);       其他情况，（*b为单分支结点或叶结点）

   具体算法实现如下：

   ```c++
      int DeonNodes(BiTree b) {
         if (b == NULL) {
            return 0;
         } else if (b->lchild != NULL && b->rchild != NULL) {
            return DeonNodes(b->lchild)+DeonNodes(b->rchild)
         }
      }
   ```
   
   当然，本题也可以设置一个全局变量Num，每遍历到一个结点时，判断每个结点是否为分支结点，若是则Num++；
   
9. 采用后序遍历的方式，先交换结点b的左孩子的左右孩子结点，再交换结点b的右孩子的左右孩子结点，最后再交换结点b的左右孩子。代码如下

   ```c++
      void swap(BiTree b) {
         if (b) {
            swap(b->lchild);
            swap(b->rchild);
            temp = b->lchild;
            b->lchild = b->rchild;
            b->rchild = temp;
         }
      }
   ```
   
10. 设置一个全局变量i（初值为1）来表示进行先序遍历时，当前访问的时第几个结点。然后可以借用先序遍历的代码模型，先序遍历二叉树。当二叉树b为空时，返回特殊字符‘#’：当k==i时，该结点即为要找的结点，返回b->data;当k!=i时，递归在左子树中查找，若找到则返回该值，否则继续递归在右子树中查找，并返回其结果。对应递归模型如下：

    - f(b, k) = '#'                                                               当b=NULL时
    - f(b, k) = b->data                                                           当i=k时
    - f(b, k) = (ch = f(b->lchild, k)) == '#' ? (ch = f(b->rchild, k) : ch        其他情况

   算法时下如下

   ```c++
      int i = 1;
      ElemType PreNode(BiTree b, int k) {
         if (b == NULL) {
            return '#';
         }
   
         if (i == k) {
            return b->data;
         }
   
         i++;
   
         ch = PreNode(b->lchild, k);
   
         if (ch != '#') {
            return ch
         }
   
         ch = PreNode(b->rchild, k);
         return ch;
      }
   ```
   本题实质上就是一个遍历算法的实现，只不过用一个全局变量来记录访问的序号，求其他遍历序列的第k个结点也采用相似的方法。
11. 删除以元素x为根的子树，只能删除其左、右子树，就可以释放值为x的根结点，因此宜采用后序遍历。 算法的实质：要删除以x值为根的子树，意味着应将其父结点的左（右）子女指针置空，用层次遍历易于找到某结点的父结点。本题要求删除树中每个元素值为x的结点的子树，因此要遍历完整整棵二叉树。算法实现如下：

   ```c++
    void DeleteXTree(BiTree &bt) {
         if (bt) {
            DeleteXTree(bt->lchild)
            DeleteXTree(bt->rchild)
            free(bt)
         }
    }
   
    void Search(BiTree bt, ElemType x) {
         BiTree Q[];
         if (bt) {
            if (bt->data == x) {
               DeleteXTree(bt);
               exit(0)
            }
   
            InitQueue(Q);
            Enqueue(Q, bt);
   
            while(!IsEmpty(Q)) {
               Dequeue(Q, p)
               if (p->lchild) {
                  if (bt->lchild->data == x) {
                     DeleteXTree(bt->lchild);
                     bt->lchild = NULL;
                  }
               } else {
                   Enqueue(Q->lchild, bt);
               }
   
                if (p->rchild) {
                  if (bt->rchild->data == x) {
                     DeleteXTree(bt->rchild);
                     bt->rchild = NULL;
                  }
               } else {
                   Enqueue(Q->rchild, bt);
               }
            }           
         }
    }
   ```

12. 算法思想： 采用非递归后序遍历，最后访问根结点，访问到值为x的结点时，栈中所有元素均为该结点的祖先，依此打印即可，算法实现如下：

   ```c++
      typedef struct {
         BiTree t;
         int    tag;
      }stack;
   
      void Search(BiTree bt, ElemType x) {
         stack s[];
         top=0;
         while(bt != NULL || top > 0) {
            while(bt != NULL && bt->data != x) {
               s[++top].t = bt;
               s[top].tag = 0;
               bt = bt->lchild;
            }
            if (bt != NULL && bt->data == x) {
               printf("所查结点的所有祖先结点的值为：\n");
               for (i = 1; i <= top; i++) {
                  printf("%d", s[i].t->data);
               }
   
               exit(1);
            }
   
            while(top != 0 && s[top].tag ==1) {
               top--;
            }
   
            if (top != 0) {
               s[top].tag = 1;
               bt=s[top].t->rhcild;
            }
         }
      }
   ```

   因为查找过程就是后序遍历的过程，所以使用的栈不超过树的深度。
13. 后序遍历最后访问根结点，即在递归算法中，根是压在栈底的。本题要找p和q的最近公共祖先结点r，不失一般性，设p在q的左边。算法思想：采用后序非递归算法，栈中存放二叉树的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。后序遍历必先遍历到结点p，栈中元素均为p的祖先。先将栈复制到另一辅助栈中。继续遍历到结点q时，将栈中元素从栈顶开始逐个到辅助栈中去匹配，第一个匹配（即相等）的元素就是结点p和q的最近公共祖先。
   
   ```
      typedef struct {
         BiTree t;
         int tag;    // tag=0表示左子女已被访问， tag=1表示右子女已经被访问
      }Stack;
   
      Stack S[], S1[];
      BiTree Ancestor(BiTree ROOT, BiTNode *p, BiTNode *q) {
         top = 0; bt = ROOT;
         while(bt != NULL || top > 0) {
            while (bt != NULL) {
               S[++top].t = bt;
               S[top].tag = 0;
               bt = bt->lchild;
            }
            while(top !=0 && s[top].tag == 1) {
               if (s[top].t == p) {
                  for (i = 1; i < top; i++) {
                     s1[i] = s[i];
                     top1 = top;
                  }
               }
               if (s[top].t == q) {
                  for (i=top; i>0; i--) {
                     for (j = top1; j > 0; j--) {
                        if (s1[j] == s[i].t) {
                           return s[i].t
                        }
                     }
                  }
               }
               top--;
            }
            if (top != 0) {
               s[top].tag = 1;
               bt=s[top].t->child;
            }
         }
         
         
      }
   ```
   
14. 采用层序遍历的方法求出所有结点的层次，并将所有结点和对应层次放在一个队列中。然后通过扫描队列求出各层的结点总数，最大的层结点总数即为二叉树的宽度。算法实现如下：

   ```c++
      typedef struct {
         BiTree data[MaxSize];
         int level[MaxSize];
         int front, rear;
      }Qu;
   
      int BTWidth(BiTree b) {
         BiTree p;
         int k, max, i, n;
         Qu.front = Qu.rear = -1;
         Qu.rear++;
         Qu.data[Qu.rear] = b;
         Qu.level[Qu.rear] = 1;
         while (Qu.front < Qu.rear) {
               Qu.front++;
               p=Qu.data[Qu.front];
               k=Qu.level[Qu.front];
               if (p->lchild != NULL) {
                  Qu.rear++;
                  Qu.data[Qu.rear]=p->lchild;
                  Qu.level[Qu.rear] = k+1;
               }
               if (p->rchild != NULL) {
                  Qu.rear++;
                  Qu.data[Qu.rear]=p->rchild;
                  Qu.level[Qu.rear] = k+1;
               }
         }
         max = 0; i = 0;
         k = 1;
         while(i <= Qu.rear) {
            n=0;
            while(i < Qu.rear && Qu.level[i] == k) {
               n++;
               i++;
            }
            k=Qu.level[i];
            if (n > max) {
               max = n;
            }
         }
   
         return max;
      }
   ```
   
15. 对于一般的二叉树，仅根据先序或者后序序列，不能确定另一个遍历序列。但对于满二叉树，任意一个结点的左、右子树均含有相等的结点数，同时，先序序列的第一个结点作为后序序列的最后一个结点，由此得到将先序序列pre[l1..h1]转换为后序序列post[l2..h2]的递归模型如下：

    - f(pre, l1, h1, post, l2, h2) = 不做任何事情              h1 < l1时
    - f(pre, l1, h1, post, l2, h2) = post[h2]=pre[l1]        其他情况
      - 取中间位置half=(h1-l1)/2;
      - 将pre[l1+1, l1+half]左子树转换为post[l2, l2+half-1],
      - 即f(pre, l1+1, l1+half, post, l2, l2+half-1),
      - 将pre[l1+half+1, h1]左子树转换为post[l2+half, h2-1],
   其中，post[h2]=pre[l1] 表示后序序列的最后一个结点（根结点）等于先序序列的第一个结点（根结点）相应算法实现如下

   ```c++
      void preToPost(ElemType pre[], int l1, int h1,ElemType post[],int l2,int h2) {
         int half;
         if (l1 <= h1) {
            post[h2] = pre[l1]
            half = (h2-h1)/2;
            preToPost(pre, l1+1, l1+half, post, l2, l2+half-1);
            preToPost(pre, l1+1+half, h1, post, l2+half, h2-1);
         }
      }
   ```
   
16. 通常使用的先序、中序和后序遍历对叶结点的访问顺序都是从左到右的，这里选择中序递归遍历。算法思想：设置前驱结点指针pre，初始为空。第一个叶结点由指针head指向，遍历到叶结点时，就将它前驱的rchild指针指向它，最后一个叶结点的rchild为空。算法实现如下：

   ```c++
      LinkedList head, pre = NULL;
      LinkedList InOrder(BiTree bt) {
         if (bt) {
            InOrder(bt->lchild);
            if (bt->lchild == NULL && bt->rchild == NULL) {
               if (pre == NULL) {
                  head = bt;
                  pre = bt;
               } else {
                  pre->rchild = bt;
                  pre = bt;
               }
               InOrder(bt->rchild);
               pre->rchild = NULL;
            }
         }
   
         return head;
      }
   ```
   
   上述算法的时间复杂度为O(n), 辅助变量使用head和pre，栈空间复杂度为O(n)。

17. 本题采用递归的思想求解，若T1和T2都是空树，则相似；若有一个为空另一个不为空，则必然不不想似；否则递归地比较他们的左、右子树是否相似。递归函数的定义如下：

   - f(T1, T2) = 1; 若T1==T2==NULL。
   - f(T1, T2) = 0; 若T1和T2之一为NULL,另一个不为NULL。
   - f(T1,T2)=f(T1->1child,T2->1child)&&f(T1->rchild,T2->rchild);T1和T2均不为NULL。
   
   算法实现如下：

   ```c++
      int similar(BiTree T1, BiTree T2) {
         int lefts, rights;
         if (T1 == NULL && T2 == NULL) {
            return 1;
         }
   
         if (T1 == NULL || T2 == NULL) {
            return 0;
         } else {
            lefts = similar(T1->lchild, T2->lchild);
            rights = similar(T1->rchild, T2->rchild);
            return lefts && rights
         }
   
         
   
      }
   ```
   
18. 算法思想：在后序序列中，若结点p有右子女，则右子女是其前驱，若无右子女而有左子女，则左子女是其前驱。若结点p左、右子女均无，设其中序左线索指向某祖先结点f（p时f右子树中按中序遍历的第一个结点），若有左子女，则其左子女是结点p在后序下的前驱；若f无左子女，则顺其前驱找双亲的双亲，一直找到双亲有左子女（这时左子女是p的前驱）。还有一种情况，若p是中序遍历的第一个结点，则结点p是在中序和后序下均无前驱。

   算法代码如下：

   ```c++
      BiThrTree  InPostPre(BiThrTree t, BiThrTree p) {
         // 在中序线索二叉树t中，求制定结点p在后序下的前驱结点q
         BiThrTree q;
         if (p->rtag == 0) {
            q = p->rchild;
         } else if (p->ltag == 0) {
            q = p->lchild;
         } else if (p->lchild == NULL) { // p是中序序列的第一结点，无后序前驱（自己画一下中序线索二叉树的图）
            q = NULL;
         } else {
            while (p->ltag == 1 && p->lchild != NULL) {
                p = p->lchild;
            }
   
            if (p->ltag == 0) {
               q = p->lchild;
            } else {
               q = NULL;
            }
         }
   
         return NULL;
      }
   ```

   
20. 1) 算法的基本思想

表达式的中序序列加上必要的括号即为等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。

表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定，为得到正确的中缀表达式，需要在生成遍历序列的同时，在适当的位置增加必要的括号。显然，表达式的最外层（对应根结点）和操作数（对应叶结点）不需要括号

2) 算法实现

将二叉树的中序遍历递归算法稍加改造即可得本题的答案。根结点和叶结点除外，遍历其它结点时在遍历其左子树之前加上括号，遍历完右子树后加上右括号

```c++
   void BtreeToE(BTree *root) {
      BtreeToExp(root, 1)                                                  // 树的高度为1
   }
   
   void BtreeToExp(BTree *root, int deep) {
      if (root == NULL) return;                                            // 空结点返回 
      else if (root->left == NULL && root->right == NULL) {                // 若为叶结点
         printf("%s", root->data);                                         // 输出操作数，不加括号
      } else {
         if (deep > 1) {                                                   // 若有子表达式则加1层括号
            printf("(");
         }
         
         BtreeToExp(root->left, deep+1);
         printf("%s", root->data);                                         // 输出操作符
         BtreeToExp(root->right, deep+1);
         if (deep > 1) {
            printf(")")                                                    // 如果有子表达式则加一层括号
         }
      }
   }
```

21. 解法1
1) 算法的基本设计思想

   对于采用顺序存储方式保存的二叉树，根结点保存在SqBiTNode[0]中；当某结点保存在SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中；若有右孩子，则其值保存在SqBiTNode[2i+2]中；若有双亲结点，则其值保存在SqBiTNode[(i-1)/2]中。

   二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右于树中的全部结点值。中序遍历二叉搜索树得到一个升序序列

   使用整形变量val记录中序遍历过程中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于或等于val，则算法返回false，否则，将val的值更新为当前结点的值。

2) 算法实现

   ```c++
      #define false 0;
      #defube true 1;
      typedef int bool;
   
      bool judgeInOrderBST(SqBiTree bt, int k, int *val) {
         if (k < bt.ElemNum && bt.SqBiTNode[k] != -1) {
            if (!judgeInOrderBST(BT, 2*K+1, val)) return false;
            if (bt.SqBiTNode[k] <= *val) return false;
            *val = bt.SqBiTNode[k];
            if (!judgeInOrderBST(BT, 2*K+2, val)) return false;
         }
      }
   ```
   
解法二 
1) 算法的基本设计思想。
   对于采用顺序存储方式保存的二叉树，根结点保存在SqBiTNode[0]中：当某结点保存在 SqBiTNode[i]中时，若有左孩子，则其值保存在SqBiTNode[2i+1]中；若有右孩子，则其值 保存在SqBiTNode[2i+2]中：若有双亲结点，则其值保存在SqBiTNode[(i-1)/2]中。 二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子 树中的全部结点值。设置两个数组pmax和pmin。根据二叉搜索树的定义，SqBiTNode[i]中的值应该大于以SqBiTNode[2i+1]为根的子树中的最大值（保存在pma×[2i+1]中），小于以SqBiTNode[2i+2]为根的子树中的最小值（保存在pmin[2i+1]中）。初始时，用数组SqBiTNode中前ElemNum个元素的对数组pmax和pmin初始化。在数组SqBiTNode中从后向前扫描，扫描过程中逐一验证结点与子树之间是否满足上述的 大小关系。
2) 算法实现

   ```c++
      #define flase 0;
      #define true 1;
      typedef int bool;
      bool judgeBST(SqBiTree bt) {
         int k, m, *pmin, *pmax
         pmin = (int *) malloc(sizeof(int)*(bt.ElemNum));
         pmin = (int *) malloc(sizeof(int)*(bt.ElemNum));
   
         for(k=0; k < bt.ElemNum; k++) {
            pmin[k] = pmax[k] = bt.SqBiTNode[k];
         }
         for(k=bt.ElemNum-1; k > 0; k--) {
            if (bt.SqBiTNode[k] != -1) {
               m = (k-1)/2;
               if (k%2 == 1&&bt.SqBiTNode[m] > pmax[k]) {
                  pmin[m] = pmin[k];
               } else if (k%2 == 0&&bt.SqBiTNode[m] < pmax[k]) {
                  pmin[m] = pmin[k];
               } else {
                  return false;
               }
            }
         }
         return true;
      }
   ```
   
## 5.4 树、森林

### 5.4.1 树的存储结构

1. 双亲表示法

   这种结构采用一组连续的空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。如下图所示，根结点下标为0，其伪指针域为-1.

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308280850562.png)

   双亲表示法存储结构描述如下：

   ```c++
      #define MAX_TREE_SIZE 100              // 树中最多结点数
      typedef struct {                       // 树结点定义
         ElemType data;                      // 数据元素
         int parent;                         // 双亲位置域
      }PTNode;
      typedef struct {                       // 树的类型定义
         PTNode nodes[MAX_TREE_SUZE];        // 双亲表示
         int n;                              // 结点数
      }PTree;
   ```
   
   该存储利用了每个结点只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。

   注意：区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点的关系。当然二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不能用二叉树的存储结构来存储。
2. 孩子表示法

   孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表， 如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308290853415.png)

   这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表
3. 孩子兄弟表示法

   孩子兄弟表示法又称二叉树表示法，即以二叉树链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点的第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点），如下图所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308290902190.png)

   孩子兄弟表示法的存储结构描述如下：

   ```c++
      typedef struct CSNode {
         ElemType data;
         struct CSNode *firstchild, *nextsibling;
      }CSNode, *CSTree;
   ```
   
   其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。

### 5.4.2 树、森林与二叉树的转换

树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树，如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308300832216.png)
 
树转换称二叉树的画法：
- 在兄弟结点之间加一连线；
- 对每个结点，只保留它与第一个孩子的连线，而其他孩子的连线全部抹掉
- 以树根为轴心，顺时针旋转45度

将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵和树对应的二叉树的右子树必空，若森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应二叉树当作第一个棵二叉树的根的右子树，将第三棵树对应的二叉树当作第二课二叉树根的右子树...以此类推，就可以将森林转换为二叉树。

森林转换为二叉树的画法：
- 在森林中的每棵树转换成相应的二叉树
- 每棵树的根也可视为兄弟关系，在每棵树的根之间加上一根连线
- 以第一棵树的根为轴心顺时针旋转45度。

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树转换为树，就得到了森林。二叉树转换为树或森林是唯一的。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308300850481.png)

### 5.4.3 树和森林的遍历

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式。

- 先根遍历：若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树对应二叉树的先序序列相同
- 后根遍历：若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同

另外，树也有层次遍历，与二叉树的层序遍历思想基本相同，即按层序依次访问各结点。

按照森林和树相互递归的定义，可得到森林的两种遍历方式
- 先序遍历森林。若森林为空，则按如下规则进行遍历：
  - 访问森林中第一棵树的结点
  - 先序遍历第一棵树中根结点的子树森林
  - 先序遍历除去第一棵树之后剩余的树构成的森林
- 中序遍历森林。森林为非空时，按如下规则进行遍历
  - 中序遍历森林中第一棵树的根结点的子树森林
  - 访问第一棵树的根结点
  - 中序遍历除去第一棵树之后剩余的树构成的森林。

当森林转换成二叉树时，其第一棵树的子树森林转换为左子树，剩余树的森林转换为右子树，可知森林的先序和中序遍历即为其二叉树的先序和中序遍历。

树和森林的遍历与二叉树的遍历关系见下图

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202308310820218.png)

### 5.4.4 本节试题精选

一、 选择题
1. D
2. D
3. D
4. B(A)
5. B
6. D(C)(不理解)
7. B（选对了，但是没理解解释为什么是这样解释的）
8. C
9. B(D)
10. C(B)
11. C(B)
12. A(D)
13. D(C)
14. A(C)
15. B
16. A(C)
17. B(C)
18. A(C)

二、综合应用题

1. 一棵树的先根遍历结果与其对应二叉树的先序遍历结果相同，树的后根遍历结果与其对应二叉树表示的中序遍历结果相同。由于二叉树的先序序列和中序序列能够唯一地确定这棵二叉树，因此，根据题目给出的条件，利用树的先根遍历序列和后根遍历序列能够唯一地确定这棵树。例如，对于右图所示的树，对应的二叉树的先序序列为1,2,3,4,5,6,8,7，中序序列为3,4,8,6,7,5,2,1。原树的先根遍历序列为1,2,3,4,5,6,8,7，后根遍历序列为3,4,8,6,7,5,2,1。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202309110852614.png)

2. 根据树与二叉树“左孩子右兄弟”的转换规则，将森林转换为二叉树的过程如下：
   - 将每棵树的根结点也视为兄弟关系，在兄弟结点之间加一连线
   - 对每个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉
   - 以树根为轴心，顺时针旋转45度。结果如下所示

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202309111900383.png)
3. 知道二叉树的先序和中序遍历后，可以唯一确定一棵树的结构。然后把二叉树转换到树和森林的方式是，若结点x是双亲y的左孩子，则把x的右孩子、右孩子的右孩子...都与y用连线连起来，最后去掉所有双亲到右孩子的连线。

   最后得到的二叉树与对应森林如下图所示。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202309110908883.png)