# 第四章 串

每次学习一个新的数据结构都要从数据结构的三要素入手：逻辑结构、数据的运算、存储结构（物理结构）

## 4.1 串的定义和实现

### 4.1.1 串的定义

参阅脑图：/数据结构/脑图/第四章 串/4.1.1 串的定义和基本操作.xmind

### 4.1.2 串的存储结构

1. 定长顺序存储的表示

类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串中定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。

```
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN];
    int length;
}SString
```

串的实际长度只能小于等于MAXLEN,超过预定义长度的串值会被舍弃，称为截断。

串长 有两种表示方法：一是如上述定义描述的那样，用一个额外的变量1en来存放串的长度；二是在串值后面加一个不计入串长的结束标记字符“\0”，此时的串长为隐含值。

2. 堆分配存储表示（没理解）

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储空间是在程序执行过程中动态分配得到的。

```c
type struct {
    char *ch;
    int length;
} HString;
```

在C语言中，存在一个称之为“堆”的自由存储区，并用ma11oc()和free()函数来完成动态存储管理。利用ma11oc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成 功，则返回一个指向起始地址指针，作为串的基地址，这个串由ch指针来指示：若分配失败，则返回NULL。已分配的空间可用free()释放掉。上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。

3. 块链存储表示

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1()是结点大小为4（即每个结点存放4个字符）的链表， 最后一个结点占不满时通常用“#”补上；图4.1b)是结点大小为1的链表。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306131927537.png)

### 4.1.3 串的基本操作

- StrAssign(&T, chars)：赋值操作。把串T赋值为charts
- StrCopy(&T, S)：复制操作。由串S复制得到串T.
- StrEmpty(S)：判空操作。若S为空串，则返回TRUE,否则返回FALSE。
- StrCompare(S, T)：比较操作。若S>T，则返回值>0；若S=T,则返回值=0；若S<T，则返回值<0。
- StrLength(S)：求串长。返回串S的元素个数。
- SubString(&Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起的长度为len的子串。
- Concat(&T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串。
- Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置：否则函数值为0。
- ClearString(&S):清空操作。将S清为空串。
- DestroyString(&S):销毁串。将串S销毁。

不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值 StrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串SubString 五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串 操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。（没理解）

## 4.2 串的模式匹配

### 4.2.1 简单的模式匹配算法

子串的定位操作通常称为串的模式匹配，它求的是子串（通常是模式串）在主串中的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的模式匹配算法。

```c
int Index(SString S, SString T) {
    int i = 1, j = 1;
    while i <= S.length && j <= T.length {
        if (S.ch[i] == T.ch[j]) {
            ++i;
            ++j;
        } else {
            i = i-j+2;
            j = 1;
        }
    }
    
    if j > T.length {
        return i-T.length;
    } else {
        return 0;
    }
}
```

在上述算法中，分别用计数指针1和j指示主串S 和模式串T中当前正待比较的字符位置。算法思想为： 从主串S第一个字符起，与模式T的第一个字符比较， 若相等，则继续逐个比较后续字符：否则从主串的下一个 字符起,重新和模式的字符比较：以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。图4.2展示了模式T='abcac'和主串S的匹配过程，每次匹配失败后，都把模式T后移一位。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306140918836.png)

最坏的时间复杂度为O(nm)：假入主串的长度为n，模式串的长度为m，那么，能够产生子串的个数为n-m+1,而每个子串在最坏情况下要匹配m次，那么时间复杂度为O((n-m+1)m)，换算为O(nm-m^2+n),因为在大多数情况下主串n，必定大于模式串m，所以坏的时间复杂度是O(nm)而不是O(m^2)