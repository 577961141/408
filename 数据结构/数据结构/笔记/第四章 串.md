# 第四章 串

每次学习一个新的数据结构都要从数据结构的三要素入手：逻辑结构、数据的运算、存储结构（物理结构）

## 4.1 串的定义和实现

### 4.1.1 串的定义

参阅脑图：/数据结构/脑图/第四章 串/4.1.1 串的定义和基本操作.xmind

### 4.1.2 串的存储结构

1. 定长顺序存储的表示

类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串中定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。

```
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN];
    int length;
}SString
```

串的实际长度只能小于等于MAXLEN,超过预定义长度的串值会被舍弃，称为截断。

串长 有两种表示方法：一是如上述定义描述的那样，用一个额外的变量1en来存放串的长度；二是在串值后面加一个不计入串长的结束标记字符“\0”，此时的串长为隐含值。

2. 堆分配存储表示（没理解）

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储空间是在程序执行过程中动态分配得到的。

```c
type struct {
    char *ch;
    int length;
} HString;
```

在C语言中，存在一个称之为“堆”的自由存储区，并用ma11oc()和free()函数来完成动态存储管理。利用ma11oc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成 功，则返回一个指向起始地址指针，作为串的基地址，这个串由ch指针来指示：若分配失败，则返回NULL。已分配的空间可用free()释放掉。上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。

3. 块链存储表示

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1()是结点大小为4（即每个结点存放4个字符）的链表， 最后一个结点占不满时通常用“#”补上；图4.1b)是结点大小为1的链表。

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202306131927537.png)

### 4.1.3 串的基本操作

- StrAssign(&T, chars)：赋值操作。把串T赋值为charts
- StrCopy(&T, S)：复制操作。由串S复制得到串T.
- StrEmpty(S)：判空操作。若S为空串，则返回TRUE,否则返回FALSE。
- StrCompare(S, T)：比较操作。若S>T，则返回值>0；若S=T,则返回值=0；若S<T，则返回值<0。
- StrLength(S)：求串长。返回串S的元素个数。
- SubString(&Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起的长度为len的子串。
- Concat(&T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串。
- Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置：否则函数值为0。
- ClearString(&S):清空操作。将S清为空串。
- DestroyString(&S):销毁串。将串S销毁。

不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值 StrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串SubString 五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串 操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。（没理解）