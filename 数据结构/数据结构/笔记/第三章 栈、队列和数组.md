# 第三章 栈、队列和数组

## 3.1 栈

### 3.1.1 栈的基本概念

**1.栈的定义**

栈是只允许在一端进行插入和删除操作的线性表。首先是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305151903798.png)

栈顶（Top）：线性表允许进行插入删除的一端

栈底（Bottom）：固定的，不允许进行插入和删除的另一端

空栈：不包含任何数据元素的空表

栈的特性可以明显的概括为先进后出（Last In First Out）

栈的数学性质：卡特兰数。公式如下

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230515190752.png)

**2.栈的基本操作**

```ADT
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

**重点：在做题的时候，如果题干没有做出任何限制，就可以直接使用这些基本的操作函数**

### 3.1.2 栈的顺序存储结构

**1.顺序栈的实现**

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。

栈的顺序存储类型可描述为

```c
#define MaxSize 50
typedef struct {
    Elemtype data[MaxSize];
    int top;
}Sqstack;
```
- 栈顶指针：S.top,初始时设置S.top=-l;栈顶元素：S.data[S.top]。
- 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。
- 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。
- 栈空条件：S.top==-1;栈满条件：S.top==MaxSize-1;
- 栈长：S.top+1。

详细的代码详见`源码\第三章\3.1.2 SequenceStack1`

**2.顺序栈的基本运算**

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1）初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（2）栈判空

```c
Status StackEmpty(SqStack *S) {
    if (S->top == -1) {
        return TRUE;
    } else {
        return FALSE;
    } 
} 
```

（3）进栈

```c
Status Push(SqStack *S, SElemType e) {
    if (S->top == MaxSize - 1) { // 栈满了
        return FALSE;
    }
    
    S->data[++S->top] = e;
    
    return TRUE;
} 
```

（4）出栈
```
Status Pop(SqStack *S, SElemType *e) {
    if (S->top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top--];
    
    return TRUE;
} 
```

（5）对栈顶元素

```c
Status GetTop(SqStack S, SElemType *e) {
    if (S.top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top-1];
    
    return TRUE;
} 
```

注意：这里的top指向的是栈顶元素，所以进栈操作为S.data[++S->top] = x,出栈操作为x=S.data[S->top--].如果栈顶指针初始化为S.top=0，即top指向栈顶元素的下一个位置，则入栈操作变为S.data[S->top++],出栈操作为x=S.data[--S->top],相应的栈空，栈满两条件也会发生变化，代码详见`源码\第三章\3.1.2 SequenceStack2`。做题时需要注意。可以参阅

**3.共享栈**

利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230516182731.png)

两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MAXSIZE时1号栈为空；仅当两个栈顶指针相邻（top1-top0 = 1） ，判断为栈满。当0号进栈时top0先加1再赋值，1好栈进栈时top1先减1再赋值，出栈时正好相反。


共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为O(1),所以对存取效率没有什么影响。

代码详见`源码\第三章\3.1.2 SqDoubleStack`

### 3.1.3 栈的链式存储结构

采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况，通常采用单链表实现，并规定所有操作都在单链表的表头进行，这里规定链栈没有头结点，Lhead指向栈顶元素，如下图
![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305160858084.png)

栈的链式存储类型可描述为

```c
typedef struct Linknode {
    SElemType data;
    struct Linknode *next;
}*LiStack;
```

采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同(详见代码3.1.3 LinkStack1 和 3.1.3 LinkStack2)。

### 3.1.4
一、选择题
1. A(B，因为逻辑结构都是线性结构)
2. C 
3. B 
4. C 
5. A 
6. A 
7. D(C,这道题没理解。解释 对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而单循环链表通过尾指针可以很方便地找到表头结点，但通过 头指针找尾结点则需要遍历一次链表。对于C,插入和删除结点后，找尾结点需要花费O()
的时间。) 
8. C 
9. D 
10. A 
11. (B),解法公式如下
    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305190855026.png)
12. D 
13. D 
14. B(D,可以自己举例子) 
15. B(D,当第i个元素第一个出栈，则i之前的元素可以一次排在i之后出栈，但剩余的元素可以在此时进栈并且也会排在i之前的元素出栈，所以第j个元素不确定) 
16. C 
17. C 
18. D(C，可以自己举例子) 
19. A(C, 标识符只能是英文字母或下画线开头，而不能是数字开头。故由n、1、_三个字符组合成的标识服有n1_,n_1,_1n和_n1四种。但是不可能出现_n1这种情况（可以自己模拟一下）) 
20. B 
21. A 
22. C 
23. D 
24. B 
25. B(C,显然，3之后的4，5，...，n都是P3可以取的数（一直进栈直到该树入栈后马上出栈）。接下来分析1和2是否可取：P1可以是3之前入栈的数（可能是1或2），也可以是4，当P1=1时，P3可取2；当P1=2时，P3可取1.故P3可能取除3之外的所有数，个数为n-1) 
26. A(C I的反例：计算斐波拉契数列迭代实现只需要一个循环即可实现。Π的反例：入找序列为1,2，进行Push,Push,Pop,Pop操作，出栈次序为2、1：进行Push,Pop,Push,Pop操作，出栈次序为 1,2。IV,找是一种受限的线性表，·只允许在一端进行操作。Ⅱ正确。) 
27. B 
28. D
29. D

二、综合应用题

1. 答：三种；分别是：CDBAE、CDEBA、CDBEA
2. 答：B、C、A、E、D可以。可由A进，B进，B出，C进，C出，A出，D进，E进，E出，D出得到。D、B、A、C、E不行，原因：栈是先进先出的，如果D先出栈，这时候栈里面有ABC三个数据元素在里面了，那么C的出栈顺序一定在B与A之前
3. 1）ACD（AD合法，而B、C不合法.注意题目里的条件，题目里说了初始状态和终态始终为空，而C的终态最后还是会剩下II）2) 设被判定的操作序列已存入一维数组A中。算法的基本设计思想：依次逐一扫描入栈出栈序列（即由“I“和“O”组成的字符串），每扫描至任意一个位置均需检查出栈的次数（即“O”的个数）是否小于入栈次数（“I”的个数），若大于则为非法序列。扫描结束后，再判断入栈和出栈的次数是否相等，若不想等就不合题意，为非法序列

```c
#include "stdio.h"    
#include "stdbool.h"

bool Judge(char A[]) {
    int i = 0;  // 遍寻字符A
    int j = 0;  // 入栈次数
    int k = 0;  // 出栈次数

    while (A[i] != '\0') { // 还没到换行符
        switch (A[i]) {
            case 'I' :
                j++; // 入栈加一
                break;
            case 'O':
                k++; // 出栈加一
                if (k > j) { //  出栈超过了进栈
                    printf("序列非法\n");
                    return false;
                }
                break;
        }
        i++;
    }

    if (j > k) { // 遍寻完了，出栈还是大于出栈，说明还有元素，不是空态
        printf("序列非法\n");
        return false;
    } else {
        printf("序列合法\n");
        return true;
    }
} 
```
4. （算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处
   理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，两个元素比较，
   若相等，则将链表中的下一个元素与栈中再弹出的元素比较，直至链表到尾。这时若栈是空栈，
   则得出链表中心对称的结论：否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非
   中心对称，结束算法的执行。）
```c
bool dc(LinkList L, int n) {
    int i;
    char s[n/2];                        // 往下取整(5/2 = 2)
    LNode *p = L->next;                 // 工作指针（这里说明有头结点）

    for (i = 0; i < n/2; i++) {         // 链表前的一般进入栈
        s[i] = *p->data;
        *p = *p->next;
    }
    i--;                                // 恢复最后的i值
    if (n%2 == 1) {                     // 若n是奇数，后移一位
        *p = *p->next;
    }

    if (*p != NULL && s[i] == *p->data) { // 检测是否中心堆成
        i--;                              // i充当栈顶指针 
        *p = *p->next;
    }

    if (i == -1) {                      // 栈为空栈
        return true;                    // 中心对称
    } else {
        return false;
    }
}
```
算法先将“链表的前一半”元素（字符）进栈。当为偶数时，前一半和后一半的个数相同：
当为奇数时，链表中心结点字符不必比较，移动链表指针到下一字符开始比较。比较过程中遇
到不相等时，立即退出wh11e循环，不再进行比较。
本题也可以先将单链表中的元素全部入栈，然后扫描单链表工并比较，直到比较到单链表工
尾为止，但算法需要两次扫描单链表工，效率不及上述算法高。
5. 详见`源码\第三章\3.1.2 SequenceStack1`

## 3.1 队列

### 3.2.1 队列的基本概念

1. 队列的概念

队列(queue)简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端删除。向队列中插入元素称为入队或进队；删除元素称为出对或离队。其操作特性是先进先出(First In First Out,FIFO)

队头（Front）。允许删除的一端，又称为队首。

队尾（Rear）。允许插入的一端

空队列。不含任何元素的空表

2. 队列的常见操作

```
ADT 队列(Queue)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。
Operation
    InitQueue(*Q):初始化操作，建立一个空队列Q.
    DestroyQueue(*Q):若队列存在，则销毁它
    ClearQueue(*Q):将队列Q清空。
    QueueEmpty(Q):若队列Q为空，返回true，否则返回false。
    GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素
    EnQueue(*Q, e): 若队列存在，插入新元素e到队列Q中并成为队尾元素。
    DeQueue(*Q, *e):删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q):返回队列Q的元素个数。
endADT
```

### 3.2.2 队列的顺序存储结构
1. 队列的顺序存储

队列的顺序存储类型可描述为

```
#define MaxSize 50

typedef struct {
    ElemType data[MaxSize];
    int front, rear;
}SqQueue;
```
初始时：Q.front=Q.rear=0。

进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。

出队操作：队不空时，先取队头元素值，再将队头指针加1。

队空：Q.front==Q.rear。

队满：Q.front == MaxSize？并不能

2. 循环队列

操作如下：
- 初始时：Q.front=Q.rear=0。
- 队首指针进1：Q.front=(Q.front+1)%MaxSize。
- 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。
- 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize

为了区分对空还是队满，有三种处理方式：
- 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法。约定以“队头指针在队尾的下一个位置作为队满的标志”，如下所示。
    
    ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305201751076.png)

    队满条件：（Q.rear+1)%MaxSize==Q.front。
    
    队空条件：Q.front==Q.rear。

    队列长度：(Q.rear+MaxSize-Q.front)%MaxSize

    代码详见：/数据结构/数据结构/源码/第三章 栈和队列/3.2.2 Squeue1.c
- 类型中增设表示元素个数的数据成员(不牺牲空间)。这样，队空的条件为Q.size==0;队满的条件为Q.size==MaxSize.这两种情况都有Q.front=Q.rear。
    代码详见：/数据结构/数据结构/源码/第三章 栈和队列/3.2.2 Squeue2.c
- 类型中增设tag数据成员，以区分队满还是队空。tag等于0时，若因删除导致Q.front==Q.rear,则为队空；tag等于1时，若因插入导致Q.front==Q.rear，则为队满
    代码详见：代码详见：/数据结构/数据结构/源码/第三章 栈和队列/3.2.2 Squeue3.c

### 3.2.3 队列的链式存储结构
1. 队列的链式存储
   
    队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。 队列的链式存储如图。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305201833732.png)

    队列的链式存储类型可描述为
    
    ```
    typedef struct LinkNode
   {
        ElemType data;
        struct LinkNode *next;
   }LinkNode, *LinkQueuePtr;
   
   typedef struct
   {
        LinkQueuePtr *front, *rear;
        // 有些教材专门定义一个count来记录总数
   }LinkQueue;
    ```
   
    当Q.front==NULL且Q.rear==NULL链式队列为空。
    
    出队时，首先判断队列是否为空，若不空，则取出队头元素，将其从链表删除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL）.入队时，建立一个新的结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点（若原队列为空，则令Q.front也指向该结点）

   不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个
   带头结点的单链表，这样插入和删除操作就统一了，

   用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式 队列，这样就不会出现存储分配不合理和“溢出”的问题。

2. 链式队列的基本操作
    
    带头结点的操作详见：/Users/dongfangjingxu/Documents/learn-corrleation/408/数据结构/数据结构/源码/第三章 栈和队列/3.2.3 LinkQueue1.c

   带头结点的操作详见：/Users/dongfangjingxu/Documents/learn-corrleation/408/数据结构/数据结构/源码/第三章 栈和队列/LinkQueue2.c

### 3.2.4 双端队列

双端队列是指允许两端都可以进行入队和出队操作的队列。如下图所示。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端。两端都可以入队和出队

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305220900384.png)

输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如图所示：

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305221838959.png)

输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305221840138.png)

若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相连的栈。

双端队列的考点：就是推断出入队的顺序符不符合。

实际双端队列的考题不会这么复杂，通常仅判断序列是否满足题设条件，代入验证即可，

### 3.2.5

一、单项选择题
1. D
2. B
3. D
4. B
5. D
6. D(C)注意：数组A[n]的下标范围为0～n-1。如果写成A[0...n]，则说明下标范围为0～n。
7. B
8. C
9. A（B）由于队列需在双端进行操作；选项C和D的链表显然不太适合链队。选项A的链表在完成进队和出队后还要修改为循环的，对于队列来讲这是多余的（画蛇添足）。对于选项B,由于有首指针，适合删除首结点；由于有尾指针，适合在其后插入结点，故选B。
10. A
11. A
12. D
13. D
14. B（A）,按照题意循环单链表只设置了头指针，没有头结点和尾指针，进队后，循环单链表必须保持循环的性质，在只带头指针的循环单链表中寻找表尾结点的时间复杂度为O(n)，故进度时间为O(n)
15. C
16. C
17. A（B）根据题意，第一个元素进入队列后存储在A[0]处，此时front和rear的值都为0.入队时由于要执行(rear+1)%n操作，所以若入队后指针指向0，则rear初始值为n-1，而由于第一个元素在A[0]中，插入操作只改变rear指针，所以front为0不变
18. A
19. C
20. A（C）自己推理
21. D

二、综合应用
1. 详见代码/数据结构/数据结构/源码/第三章 栈和队列/Squeue3.c
2. 本题主要考查大家对队列和栈的特性与操作的理解。由于对队列的一系列操作不可能将其中 的元素逆置，而栈可以将入栈的元素逆序提取出来，因此我们可以让队列中的元素逐个地出队列， 入栈：全部入栈后再逐个出栈，入队列。算法实现如下

    ```c
    void Inverser(Stack *S, Queue *Q) {
        while(!QueueEmpty(Q)) {
            x = DeQueue(Q);
            Push(S, x);
        }
   
        while(!StackEmpty(S)) {
            x = Pop(S);
            EnQueue(Q, x);
        }
   }
    ```
3. 入队时元素放入到栈S1中，需要判断栈S1是否满了，如果满了就报错，退出。出队列时，如果S2栈和S1栈都为空，说明没有元素直接退出；如果栈S2为空，就将栈S1的所有数据全部加入到栈S2；如果S2栈不为空，就直接输出S2的栈顶元素

    ```c
   // 入队列
    bool Enqueue(Stack *S1, Stack *S2, int x) {
        if (StackOverflow(S1)) { // S1栈满了
            return false;
        }
   
        Push(S1, x);
        return true;
   }
   
   // 出队列
   bool Dequeue(Stack *S1, Stack *S2, int *x) {
        if (StackEmpty(S1) && StackEmpty(S2)) { // 两个栈都是空的
            return false;
        }
   
        if (StackEmpty(S2)) { // 第二个栈是空的
             while(!StackEmpty(S1)) { // 第一个栈还没空
                Pop(S1, x)
                Push(S2, x);
             }
        }
       
        // 从S2中出队列
        Pop(S2, x);
        return true;
   }
   
   // 判空
   bool QueueEmpty(Stack *S1, Stack *S2) {
        if (StackEmpty(S1) && StackEmpty(S2)) { // 两个栈都是空的
            return true;
        }
   
        return false;
   }
    ```

4. 1）顺序存储无法满足要求2⃣️的队列占用空间随着入队操作而增加。根据要求来分析：要求1⃣️容易满足；链式存储方便开辟新的空间，要求2⃣️容易满足；对于要求3⃣️，出队后的结点并不需要真正的释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计一个首尾相连接的循环单链表，类似于循环队列的思想。设置队头队尾指针后链式队列的入队操作和出队操作的时间复杂度均为O(1)，要求4⃣️可以满足。

    2） 该循环链式队列的实现可以参考循环队列，不同之处在于循环链式队列可以方便地增加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空闲结点的循环单链表，头指针front和尾指针rear均指向空闲结点，如下图所示。

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305240903322.png)

    队空判断条件：front == rear;

    队满判断条件：front == rear->next;

    3）插入第一个元素后的状态如下

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305241838230.png)

   4）基本操作如下

   ![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305241839304.png)
    
### 3.3 栈和队列的应用

#### 3.3.1 栈在括号匹配中的应用

参阅思想导图。

参阅源码：08/数据结构/数据结构/源码/第三章 栈和队列/3.3.1 BracketStack.c

### 3.3.2 栈在表达式中的应用

参阅思维导图

考点： 
1. 后缀表达式的计算方式的实现（重点）
   - 初始化一个栈
   - 遇到操作数就入栈（从左往右）
   - 遇到运算符就将栈顶两个操作数出栈（注意先出的一定是右边的操作数，计算的时候要特别注意（-和/）），计算完了之后再入栈，一直按照此步骤循环
   - 栈中的最后一个数一定是计算的结果
2. 前缀表达式的计算方式的实现
   - 初始化一个栈
   - 遇到操作数就入栈（从右往左）
   - 遇到运算符就将栈顶两个操作数出栈（注意先出的一定是左边的操作数，计算的时候要特别注意（-和/）），计算完了之后再入栈。一直按照此步骤循环
   - 栈中的最后一个数一定是计算的结果
3. 中缀表达式转后缀表达式的实现（重点）
   - 初始化一个栈
   - 操作数不入栈
   - 遇到“(”直接入栈
   - 遇到“)”将栈顶元素出栈，直到遇到“(”
   - 遇到运算符，要判断当前的运算符的优先级是否小于等于栈里面的运算符的优先级，如果是，则将栈里的元素出栈，直到栈里没有运算符或者栈里的运算符优先级小于当前运算符的优先级又或者在栈顶遇到了“(”，那么就直接停止
4. 中缀表达式转前缀表达式的实现
5. 中缀表达式转后缀表达式，然后再计算后缀表达式的值（用两个栈实现）
   - 就是中缀转后缀一个栈
   - 后缀求值一个栈
   - 按照中缀转后缀来计算结果和值（不懂就去看视频3.3_3）

### 3.3.3 栈在递归中的应用

递归循环不能是循环定义，其必须满足下面的条件

- 递归表达式（递归体）
- 边界条件（递归出口）

递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题

递归缺点：效率低下，通一行代码可能重复多次执行

### 3.3.4 队列在层序遍历中的应用

无

### 3.3.5 队列在计算机系统中的应用

- 解决主机与外部设备之间的速度不匹配问题
- 解决由多用户引起的资源竞争问题

### 3.3.6 试题

一、单选题

1. D
2. B
3. C
4. D（B）
5. A（B）
6. D（B）
7. C
8. B
9. A
10. B
11. A（不理解）
12. B
13. A

二、综合应用

1. 详见 /数据结构/数据结构/源码/第三章 栈和队列/3.3.1 BracketStack.c
2. 两侧的铁道均为单向行驶道，且两侧不相通。所有车辆都必须通过“栈道”进行调度。算法
   的基本设计思想：所有车厢依次前进并逐一检查，若为硬座车厢则入栈，等待最后调度。检查完
   后，所有的硬座车厢已全部入栈道，车道中的车厢均为软座车厢，此时将栈道的车厢调度出来，
   调整到软座车厢之后。算法的实现如下：

   ```c
   void Train_Arrange(char *train) {
    char *p = train, *q = train, c;
    stack s;
    InitStack(s);               // 初始化栈的结构
    while(*p) {
        if (*p == 'H') {
            Push(s, *p);        // 把H放入栈中
        }esle {
            *(q++) = *p;        // 把S调到前部
        }
        p++;
    }

    while (!StackEmpty(s)) {
        Pop(s, c);
        *(q++)=c;               // 把H接在后部
    }
   }
   ```

## 问题

1. 不带头结点的链式存储的操作
2. 