# 第三章 栈、队列和数组

## 3.1 栈

### 3.1.1 栈的基本概念

**1.栈的定义**

栈是只允许在一端进行插入和删除操作的线性表。首先是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305151903798.png)

栈顶（Top）：线性表允许进行插入删除的一端

栈底（Bottom）：固定的，不允许进行插入和删除的另一端

空栈：不包含任何数据元素的空表

栈的特性可以明显的概括为先进后出（Last In First Out）

栈的数学性质：卡特兰数。公式如下

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230515190752.png)

**2.栈的基本操作**

```ADT
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

**重点：在做题的时候，如果题干没有做出任何限制，就可以直接使用这些基本的操作函数**

### 3.1.2 栈的顺序存储结构

**1.顺序栈的实现**

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。

栈的顺序存储类型可描述为

```c
#define MaxSize 50
typedef struct {
    Elemtype data[MaxSize];
    int top;
}Sqstack;
```
- 栈顶指针：S.top,初始时设置S.top=-l;栈顶元素：S.data[S.top]。
- 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。
- 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。
- 栈空条件：S.top==-1;栈满条件：S.top==MaxSize-1;
- 栈长：S.top+1。

详细的代码详见`源码\第三章\3.1.2 SequenceStack1`

**2.顺序栈的基本运算**

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1）初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（2）栈判空

```c
Status StackEmpty(SqStack *S) {
    if (S->top == -1) {
        return TRUE;
    } else {
        return FALSE;
    } 
} 
```

（3）进栈

```c
Status Push(SqStack *S, SElemType e) {
    if (S->top == MaxSize - 1) { // 栈满了
        return FALSE;
    }
    
    S->data[++S->top] = e;
    
    return TRUE;
} 
```

（4）出栈
```
Status Pop(SqStack *S, SElemType *e) {
    if (S->top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top--];
    
    return TRUE;
} 
```

（5）对栈顶元素

```c
Status GetTop(SqStack S, SElemType *e) {
    if (S.top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top-1];
    
    return TRUE;
} 
```

注意：这里的top指向的是栈顶元素，所以进栈操作为S.data[++S->top] = x,出栈操作为x=S.data[S->top--].如果栈顶指针初始化为S.top=0，即top指向栈顶元素的下一个位置，则入栈操作变为S.data[S->top++],出栈操作为x=S.data[--S->top],相应的栈空，栈满两条件也会发生变化，代码详见`源码\第三章\3.1.2 SequenceStack2`。做题时需要注意。可以参阅

**3.共享栈**

利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230516182731.png)

两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MAXSIZE时1号栈为空；仅当两个栈顶指针相邻（top1-top0 = 1） ，判断为栈满。当0号进栈时top0先加1再赋值，1好栈进栈时top1先减1再赋值，出栈时正好相反。


共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为O(1),所以对存取效率没有什么影响。

### 3.1.3 栈的链式存储结构

采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况，通常采用单链表实现，并规定所有操作都在单链表的表头进行，这里规定链栈没有头结点，Lhead指向栈顶元素，如下图
![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305160858084.png)

栈的链式存储类型可描述为

```c
typedef struct Linknode {
    SElemType data;
    struct Linknode *next;
}*LiStack;
```

采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同(详见代码3.1.3 LinkStack1 和 3.1.3 LinkStack2)。