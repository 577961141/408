# 第三章 栈、队列和数组

## 3.1 栈

### 3.1.1 栈的基本概念

**1.栈的定义**

栈是只允许在一端进行插入和删除操作的线性表。首先是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。如下图所示

![](https://cdn.jsdelivr.net/gh/577961141/static@master/202305151903798.png)

栈顶（Top）：线性表允许进行插入删除的一端

栈底（Bottom）：固定的，不允许进行插入和删除的另一端

空栈：不包含任何数据元素的空表

栈的特性可以明显的概括为先进后出（Last In First Out）

栈的数学性质：卡特兰数。公式如下

![](https://cdn.jsdelivr.net/gh/577961141/static@master/20230515190752.png)

**2.栈的基本操作**

```ADT
ADT 栈(stack)
Data
    同线性表。元素具有相同类型，相邻元素间具有前驱和后继关系
Operation
    IniStack(*S)：初始化操作，建立一个空栈
    DeatoryStack(*S):若栈存在，则销毁它。
    ClearStack(*S):将栈清空
    StackEmpty(S):若栈为空，则返回true，否则返回false
    GetTop(S, *e):若栈存在且非空，用e返回s的栈顶元素
    Push(*S, e):若栈s存在，插入新元素e到s中并称为栈顶元素
    Pop(*S, *e):删除栈S中栈顶元素，并用e返回其数
    StackLength(s):返回栈s的元素个数
```

**重点：在做题的时候，如果题干没有做出任何限制，就可以直接使用这些基本的操作函数**

### 3.1.2 栈的顺序存储结构

**1.顺序栈的实现**

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。

栈的顺序存储类型可描述为

```c
#define MaxSize 50
typedef struct {
    Elemtype data[MaxSize];
    int top;
}Sqstack;
```
- 栈顶指针：S.top,初始时设置S.top=-l;栈顶元素：S.data[S.top]。
- 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。
- 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。
- 栈空条件：S.top==-1;栈满条件：S.top==MaxSize-1;
- 栈长：S.top+1。

详细的代码详见对应的目录

**2.顺序栈的基本运算**

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1） 初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（1）初始化

```c
Status InitStack(SqStack *S) {
    S->top = -1;
    return TRUE;
} 
```

（2）栈判空

```c
Status StackEmpty(SqStack *S) {
    if (S->top == -1) {
        return TRUE;
    } else {
        return FALSE;
    } 
} 
```

（3）进栈

```c
Status Push(SqStack *S, SElemType e) {
    if (S->top == MaxSize - 1) { // 栈满了
        return FALSE;
    }
    
    S->data[++S->top] = e;
    
    return TRUE;
} 
```

（4）出栈
```
Status Pop(SqStack *S, SElemType *e) {
    if (S->top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top--];
    
    return TRUE;
} 
```

（5）对栈顶元素

```c
Status GetTop(SqStack S, SElemType *e) {
    if (S.top == - 1) { // 栈空了
        return FALSE;
    }
    
    *e =  S->data[S->top-1];
    
    return TRUE;
} 
```
