# 数据结构

## 第一章 绪论

### 1.2 算法和算法的评价

算法时间复杂度的计算方式有两种

1. 直接分析求法，看下列例题的时间复杂度

   ```c
   void fun(int n) {
       int i = 1;
       while(i <= n) {
           i = i * 2;
       }
   }
   ```

   分析：计算基本运算 i = i*2的执行次数（每执行一次i乘2），其中判断条件理解为2^t = n，  即t = log2n。

2. 使用求和公式的解法,看如下题目

   ```c
   for(i = n-1; i > 1; i--) {
       for (j = 1; j <i; j++) {
           if (A[j] > A[k+1]) {
               A[j]与A[j+1]对换
           }
       }
   }
   ```

   分析：直接套用求和公式（请看书本），这一这种题目，内层的for和外层是有关系的，如果是3那么，就不能直接套用公式

3. 双层for没有关系求时间复杂度

   ```c
   count = 0;
   for (k = 1; k <= n; k *=2) {
       for(j = 1; j <= n; j++) {
           count++;
       }
   }
   ```

   分析：内层循环条件j<=n与外层循环的变量无关，各自独立，每执行一次j自增1，每次内层循环都执行n次。外层循环条件k <= n，增量定义为 k*=2，可知循环次数t满足k=2^t<=n，即t <= log2n.即内层循环的时间复杂度为O(n),外层循环的时间复杂度为O(log2n).对于嵌套循环。根据乘法规则可知，该段程序的时间负载度T(n) = T(n1)×T(n2)=O(n)×O(log2n)=O(nlog2n)

4. 没懂的题目，也是双层for循环

   ```c
   int sum = 0;
   for (int i = 1; i < n; i*=2) {
       for (int j = 0; j < i; j++) {
           sum++;
       }
   }
   ```

   分析：当外层循环的变量i取不同值时，内层循环就执行多次，因此总循环次数为i的所有取值之和。假设外层循环总共执行了k次，当i = 1,2,4,8,...,2^(k-1)(2^(k-1) < n < 2^(k))时，内层循环执行i次。因此总循环次数T=1+2+4+8+...+2^(k-1),即n<T<2n，时间复杂度为O(n)

### 归纳总结

这里面的内容很重要

## 第二章  线性表

### 重点

1. 要求具有最优的性能（时间复杂度、空间复杂度）
2. 牢固掌握线性表的各种基本操作
3. 只能用c/c++语言实现

### 额外的概念

1. [数据结构中存取和存储的区别](https://blog.csdn.net/m0_51495585/article/details/116110843)

### 2.1 线性表的定义和基本操作

2.1.1 线性表的定义

线性表是具有相同数据类型的n(n>=0)个数据元素的有限序列。其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则一般表示为

```
L = (a1,a2,...,an);
```

- a1称为表头元素，an称为表尾元素
- 除了a1,表中每个元素都有一个唯一直接前驱元素，除了an，表中每个元素都有唯一一个直接后继元素

线性表的特点如下：

- 表中的元素个数有限
- 表中元素具有逻辑上的顺序性，表中元素有其先后次序
- 表中元素都是数据元素，每个元素都是单个元素
- 表中元素的数据类型相同，这以为着每个元素占有相同大小的存储空间
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟是什么内容。

注意：线性表逻辑结构。顺序表和链表都是存储结构

2.1.2 线性表的操作

操作如下（看书本）

### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

线性表的顺序存储又称顺序表。他是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
   - 称i为元素ai在线性表中的位序
   - 顺序表的特点是表中的元素的逻辑顺序和物理顺序相同。

每个数据元素的存储位置都和线性表的其实位置想查一个和该数据元素的位序成正比的常数。因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储是一种随机存储结构（根据起始地址加上元素的序号，可以很方便地访问任意一个元素，这就是随机存取的概念）

> 注：线性表中元素的位序是从1开始，而数组中元素的下标从0开始的。

线性表的顺序存储类型描述如下
```c
#define MaxSize 50 // 定义线性表的最大长度

typedef struct{
   ElemType data[MaxSize];  // 顺序表中的元素
   int length; // 顺序表当前的长度
}sqList; // 顺序表的类型定义
```

一维数组可以是静态分配的，也可以是动态分配的。

动态分配如下：
````c
#define InitSize 100; // 表长度初始定义

typedef struct {
   ElemType *data; // 只是动态分配数组的指针
   int MaxSize,length; // 数组最大容量和当前个数
}SeqList;   // 动态非配数组顺序表的类型定义
````
C语言初始动态分配语句如下：
```C
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
```

- 顺序表的最主要特点是随机访问。
- 顺序表的存储密度高，每个结点值存储数据元素
- 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除需要移动大量元素。

### 2.2.2 顺序表基本操作的实现

（1）插入操作

在顺序表L的第i（1 <= i <= L.length+1）个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第i个元素及其后所有元素一次往后移动一个位置，腾出一个空位置插入新元素e，顺序表的长度增加1，插入成功，返回true。
```c
/* 插入元素 */
Status ListInsert(SqList *L, int i, ElemType e) {
    int k;
    if (L->length == MaxSize) {         /* 说明顺序表的元素满了 */
        return ERROR;
    }
    if (i < 1 || i > L->length+1) {     /* 判断i是否在有效范围内 */
        return ERROR;
    }

    // for (k = L->length; k >= i; k--) /* 将要插入位置后的元素向后移一位 */
    // {
    //     L->data[k] = L->data[k-1];
    // }

    if (i <= L->length) {               /* 如果插入数据不在表尾 */
        for (k = L->length-1; k >= i - 1; k--) /* 将要插入位置后的元素向后移一位 */
        {
            L->data[k+1] = L->data[k];
        }
        
    }

    L->data[i-1] = e;                   /* 将新元素插入 */
    L->length++;

    return OK;
}
```

> 注意区分顺序表的位序和数组下标。

时间复杂度
- 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。
- 最坏情况：在表头插入（即i=1），元素后移语句将执行n次，，时间复杂度为O(n).
- 平均情况：假设pi（pi = 1/（n+1））是在第i个位置上插入上一个结点的概率，则长度为n的线性表插入一个结点，所需要移动节点的平均次数为
  ![](https://raw.githubusercontent.com/577961141/static/master/20230408091536.png)