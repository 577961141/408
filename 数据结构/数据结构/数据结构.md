# 数据结构

## 第一章 绪论

### 1.2 算法和算法的评价

算法时间复杂度的计算方式有两种

1. 直接分析求法，看下列例题的时间复杂度

   ```c
   void fun(int n) {
       int i = 1;
       while(i <= n) {
           i = i * 2;
       }
   }
   ```

   分析：计算基本运算 i = i*2的执行次数（每执行一次i乘2），其中判断条件理解为2^t = n，  即t = log2n。

2. 使用求和公式的解法,看如下题目

   ```c
   for(i = n-1; i > 1; i--) {
       for (j = 1; j <i; j++) {
           if (A[j] > A[k+1]) {
               A[j]与A[j+1]对换
           }
       }
   }
   ```

   分析：直接套用求和公式（请看书本），这一这种题目，内层的for和外层是有关系的，如果是3那么，就不能直接套用公式

3. 双层for没有关系求时间复杂度

   ```c
   count = 0;
   for (k = 1; k <= n; k *=2) {
       for(j = 1; j <= n; j++) {
           count++;
       }
   }
   ```

   分析：内层循环条件j<=n与外层循环的变量无关，各自独立，每执行一次j自增1，每次内层循环都执行n次。外层循环条件k <= n，增量定义为 k*=2，可知循环次数t满足k=2^t<=n，即t <= log2n.即内层循环的时间复杂度为O(n),外层循环的时间复杂度为O(log2n).对于嵌套循环。根据乘法规则可知，该段程序的时间负载度T(n) = T(n1)×T(n2)=O(n)×O(log2n)=O(nlog2n)

4. 没懂的题目，也是双层for循环

   ```c
   int sum = 0;
   for (int i = 1; i < n; i*=2) {
       for (int j = 0; j < i; j++) {
           sum++;
       }
   }
   ```

   分析：当外层循环的变量i取不同值时，内层循环就执行多次，因此总循环次数为i的所有取值之和。假设外层循环总共执行了k次，当i = 1,2,4,8,...,2^(k-1)(2^(k-1) < n < 2^(k))时，内层循环执行i次。因此总循环次数T=1+2+4+8+...+2^(k-1),即n<T<2n，时间复杂度为O(n)

### 归纳总结

这里面的内容很重要

## 第二章  线性表

### 重点

1. 要求具有最优的性能（时间复杂度、空间复杂度）
2. 牢固掌握线性表的各种基本操作
3. 只能用c/c++语言实现

### 额外的概念

1. [数据结构中存取和存储的区别](https://blog.csdn.net/m0_51495585/article/details/116110843)

### 2.1 线性表的定义和基本操作

2.1.1 线性表的定义

线性表是具有相同数据类型的n(n>=0)个数据元素的有限序列。其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则一般表示为

```
L = (a1,a2,...,an);
```

- a1称为表头元素，an称为表尾元素
- 除了a1,表中每个元素都有一个唯一直接前驱元素，除了an，表中每个元素都有唯一一个直接后继元素

线性表的特点如下：

- 表中的元素个数有限
- 表中元素具有逻辑上的顺序性，表中元素有其先后次序
- 表中元素都是数据元素，每个元素都是单个元素
- 表中元素的数据类型相同，这以为着每个元素占有相同大小的存储空间
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟是什么内容。

注意：线性表逻辑结构。顺序表和链表都是存储结构

2.1.2 线性表的操作

操作如下（看书本）

### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

线性表的顺序存储又称顺序表。他是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
   - 称i为元素ai在线性表中的位序
   - 顺序表的特点是表中的元素的逻辑顺序和物理顺序相同。

每个数据元素的存储位置都和线性表的其实位置想查一个和该数据元素的位序成正比的常数。因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储是一种随机存储结构（根据起始地址加上元素的序号，可以很方便地访问任意一个元素，这就是随机存取的概念）

> 注：线性表中元素的位序是从1开始，而数组中元素的下标从0开始的。

线性表的顺序存储类型描述如下
```c
#define MaxSize 50 // 定义线性表的最大长度

typedef struct{
   ElemType data[MaxSize];  // 顺序表中的元素
   int length; // 顺序表当前的长度
}sqList; // 顺序表的类型定义
```

一维数组可以是静态分配的，也可以是动态分配的。

动态分配如下：
````c
#define InitSize 100; // 表长度初始定义

typedef struct {
   ElemType *data; // 只是动态分配数组的指针
   int MaxSize,length; // 数组最大容量和当前个数
}SeqList;   // 动态非配数组顺序表的类型定义
````
C语言初始动态分配语句如下：
```C
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
```

- 顺序表的最主要特点是随机访问。
- 顺序表的存储密度高，每个结点值存储数据元素
- 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除需要移动大量元素。

### 2.2.2 顺序表基本操作的实现

（1）插入操作

在顺序表L的第i（1 <= i <= L.length+1）个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第i个元素及其后所有元素一次往后移动一个位置，腾出一个空位置插入新元素e，顺序表的长度增加1，插入成功，返回true。
```c
/* 插入元素 */
Status ListInsert(SqList *L, int i, ElemType e) {
    int k;
    if (L->length == MaxSize) {         /* 说明顺序表的元素满了 */
        return ERROR;
    }
    if (i < 1 || i > L->length+1) {     /* 判断i是否在有效范围内 */
        return ERROR;
    }

    // for (k = L->length; k >= i; k--) /* 将要插入位置后的元素向后移一位 */
    // {
    //     L->data[k] = L->data[k-1];
    // }

    if (i <= L->length) {               /* 如果插入数据不在表尾 */
        for (k = L->length-1; k >= i - 1; k--) /* 将要插入位置后的元素向后移一位 */
        {
            L->data[k+1] = L->data[k];
        }
        
    }

    L->data[i-1] = e;                   /* 将新元素插入 */
    L->length++;

    return OK;
}
```

> 注意区分顺序表的位序和数组下标。

时间复杂度
- 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。
- 最坏情况：在表头插入（即i=1），元素后移语句将执行n次，，时间复杂度为O(n).
- 平均情况：假设pi（pi = 1/（n+1））是在第i个位置上插入上一个结点的概率，则长度为n的线性表插入一个结点，所需要移动节点的平均次数为
  ![](https://raw.githubusercontent.com/577961141/static/master/20230408091536.png)

（2） 删除操作

删除顺序表L中第i（1<=i<=L.length）个位置的元素，用变量e返回。若i的输入不合法，则返回false；否则，将被删除元素复制给引用变量e，并将第i+1个元素及其后所有元素一次往前移动一个位置，返回true；

```c
Status ListDelete(SqList *L, int i, ElemType *e)
{
    if (i > L->length || i < 1) {
        return ERROR;
    }

    if (L->length == 0) {
        return ERROR;
    }

    *e = L->data[i-1];
    for (int j = i; j < L->length; j++) {
        L->data[j-1] = L->data[j];
    }

    L->length--;
    return OK;
}
```

时间复杂度：
- 最好的情况：O(1);
- 最坏的情况：O(n);
- 平均的情况：O(n)，计算公式如下
![](https://raw.githubusercontent.com/577961141/static/master/20230410084938.png)

（3） 按值查找（顺序查找）
在顺序表L中查找第一个元素值等于e的元素，返回其位序。

```c
int LocalElem(SqList L, ElemType e)
{
    for (int i = 0; i < L.length; i++) {
        if (L.data[i+1] == e) {
            return i+1;
        }
    }

    return 0;
}
```
时间复杂度
- 最好情况：O(1),元素就在表头。
- 最坏情况：O(n),元素在表尾或者不存在
- 平均情况：O(n),计算公式如下：
![](https://raw.githubusercontent.com/577961141/static/master/20230410085636.png)

练习笔记：

1. 顺序表所占用的存储空间 = 表长*sizeof(元素的类型)，表长和元素的类型显然会影响存储空间的大小。若元素为结构体类型，则元素中各字段的类型也会影响存储空间的大小。

应用题：

1. 题解如下
```c
Status ListDeleteMinVal(SqList *L, ElemType *val)
{
    if (L->length == 0) {
        printf("顺序表为空，无法找到最小的元素并执行删除操作");
        return FALSE;
    }

    // 错误写法
    // *val = 0; // 如果这样写，那么顺序表中如果都大于0，就会出现一个问题，那默认返回的就是0，删除的也是第一个数
    *val = L->data[0];
    int minLocation = 0;

    for (int i = 0; i < L->length; i++) {
        if (*val > L->data[i]) {
            *val = L->data[i];
            minLocation = i;
        }
    }

    // 错误写法。为什么？ 这是插入，不是替换啊
    // ListInsert(L, minLocation+1, L->data[L->length-1]);
    L->data[minLocation] = L->data[L->length - 1];
    L->length--;
    return TRUE;
}
```

2. 题解如下(采用双指针的方法)
```c
Status reverseList(SqList *L) {
    if (L->length == 0) {
        return OK;
    }

    // 错误写法，为什么？ 你想想你再链表中定于的元素类型是什么，是ElemType。所以这里应该定义的是ElemType而不是int
    // int tmp = 0;

    ElemType tmp;
    for (int i = 0, j =  L->length - 1; i < j; i++, j--) {
        tmp = L->data[i];
        L->data[i] = L->data[j];
        L->data[j] = tmp;
    }

    return OK;
}
```

3. 题解如下：
解法1：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度。
```c
void ListDeleteSpecificVal(SqList *L, ElemType x) {
    // 错误解法
    // if (L->length == 0) {
    //     return ERROR;
    // }

    // int k = 0;
    // for (int i = 0; i < L->length; i++) {
    //     if (L->data[i] != x) {
    //         k++;
    //     }
    // }

    // int length = k;
    // for (int j = L->length - 1; j > 0; j--) {
    //     if (L->data[j] != x) { // 错误。把j写成i
    //         L->data[--k] = L->data[j]; // 错误,没写分号
    //     }
    // }

    // L->length = length;

    int k = 0, i;

    for (i = 0; i < L->length; i++) {
        if (L->data[i] != x) {
            L->data[k] = L->data[i];
            k++;
        }
    }
    L->length = k;
}
```

解法2：用k记录顺序表L中等于x的元素个数，边扫描L边统计k，并将不等于x的元素迁移k个元素，扫描结束过后修改L的长度
```c
void del_x_2(SqList *L, ElemType x) {
    int k = 0, i = 0;
    while (i < L->length) {
        if (L->data[i] == x) {
            k++;
        } else {
            L->data[i - k] = L->data[i];
        }
        i++;
    }
    L->length = i;
}
```

### 2.2 线性表的链式表示

#### 2.3.1 单链表的定义

线性表的链式存储又称为单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。

单链表每个节点的数据域和指针域如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230412084707.png)

数据域用来存放数据元素，指针域用来存放后继结点的地址

单链表中节点类型描述如下：
```c
typedef struct LNode {
   Elemtype data;
   struct LNode *next;
}LNode;

typedef struct LNode *LinkList
```

利用单链表可以解决顺序表需要大量连续存储单元你的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从头开始遍历，依次查找

通常用一个头指针来标识一个链表，如单链表L，头指针为NULL时表示为一个空表。此外，为了操作方便，在单链表的第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不存任何信息或者存储表长等信息，头结点的指针域指向线性表的第一个元素的结点，如下图所示

![](https://raw.githubusercontent.com/577961141/static/master/20230412183324.png)

头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点。而头结点是带头结点的链表中第一个结点，结点内通常不存储信息。

引入头结点后，带来的两个优点：

- 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表其他位置上的操作一致，无需进行特殊处理。
- 无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。

#### 2.3.1 单链表上基本操作的实现

1. 采用头插法建立单链表

该方法从一个空链表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。

代码如下：
```c
Status List_HeadInsert(LinkList *L)  {
   LinkList s;
   int x;

   *L = (LinkList)malloc(sizeof(Node));            /* 产生头结点，并使L指向此头结点 */
   
   if (!(*L)) {
      return ERROR;
   }
   
   (*L)->next = NULL;                              /* 设置头结点的指针域为空 */
   scanf("%d", &x);                                /* 输入结点的值 */
   while(x != 9999) {                              /* 输入9999表示结束 */
      s = (LinkList)mall(sizeof(Node));            /* 创建新的结点 */
      s->data = x;
      s->next = (*L)->next;
      (*L)->next = s;                              /* 将新节点插入到表中，L为头指针 */
      sacnf("%d", x);
   }
   
   return OK;
}
```

采用头插法建立单链表时，读入数据的顺序与生成链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长为n，则总时间复杂度为O(n)。

如果没有设立头结点，代码修改如下：
```c
Status List_HeadInsert(LinkList *L) {
    LinkList s, tmp;
    int x;

    s = (LinkList)malloc(sizeof(Node)); /* 每次分配内存都应该判断一下 */
    scanf("%d", &x);

    if (x == 9999) {
        return OK;
    }

    s->data = x;
    s->next = NULL;
    *L = s;

    scanf("%d", &x);
    while(x != 9999) {
      s = (LinkList)malloc(sizeof(Node));
      s->data = x;
      s->next = *L;
      *L = s;
      scanf("%d", x)
    }

   return OK;
}
```

2. 采用尾插法建立单链表

采用头插法建立链表虽然简单。但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者一致，可以采用尾插法。该方法将新结点插入到当前链表的末尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。如下图（记得上传图床）


代码如下
```c
Status List_TailInsert(LinkList *L) {
    LinkList s,r;                           /* 定义结点类型 */
    int x;                                  /* 设置元素类型为整形 */

    *L = (LinkList)malloc(sizeof(Node));    /* 初始化链表 */
    if (!(*L)) {
        return ERROR;
    }

    r = (LinkList)malloc(sizeof(Node));     /* 尾指针，记录尾结点 */
    r = *L;

    scanf("%d", &x);

    while(x != 9999) {                      /* 输入9999表示结束 */
        s = (LinkList)malloc(sizeof(Node));
        s->data = x;
        r->next = s;
        r = s;                             /* r只想新的表尾的结点 */
        scanf("%d", &x);
    }
    
    r->next = NULL;                        /* 尾结点指针置空 */

    return OK;
}
```