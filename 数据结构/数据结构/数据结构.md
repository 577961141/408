# 数据结构

## 第一章 绪论

### 1.2 算法和算法的评价

算法时间复杂度的计算方式有两种

1. 直接分析求法，看下列例题的时间复杂度

   ```c
   void fun(int n) {
       int i = 1;
       while(i <= n) {
           i = i * 2;
       }
   }
   ```

   分析：计算基本运算 i = i*2的执行次数（每执行一次i乘2），其中判断条件理解为2^t = n，  即t = log2n。

2. 使用求和公式的解法,看如下题目

   ```c
   for(i = n-1; i > 1; i--) {
       for (j = 1; j <i; j++) {
           if (A[j] > A[k+1]) {
               A[j]与A[j+1]对换
           }
       }
   }
   ```

   分析：直接套用求和公式（请看书本），这一这种题目，内层的for和外层是有关系的，如果是3那么，就不能直接套用公式

3. 双层for没有关系求时间复杂度

   ```c
   count = 0;
   for (k = 1; k <= n; k *=2) {
       for(j = 1; j <= n; j++) {
           count++;
       }
   }
   ```

   分析：内层循环条件j<=n与外层循环的变量无关，各自独立，每执行一次j自增1，每次内层循环都执行n次。外层循环条件k <= n，增量定义为 k*=2，可知循环次数t满足k=2^t<=n，即t <= log2n.即内层循环的时间复杂度为O(n),外层循环的时间复杂度为O(log2n).对于嵌套循环。根据乘法规则可知，该段程序的时间负载度T(n) = T(n1)×T(n2)=O(n)×O(log2n)=O(nlog2n)

4. 没懂的题目，也是双层for循环

   ```c
   int sum = 0;
   for (int i = 1; i < n; i*=2) {
       for (int j = 0; j < i; j++) {
           sum++;
       }
   }
   ```

   分析：当外层循环的变量i取不同值时，内层循环就执行多次，因此总循环次数为i的所有取值之和。假设外层循环总共执行了k次，当i = 1,2,4,8,...,2^(k-1)(2^(k-1) < n < 2^(k))时，内层循环执行i次。因此总循环次数T=1+2+4+8+...+2^(k-1),即n<T<2n，时间复杂度为O(n)

### 归纳总结

这里面的内容很重要

## 第二章  线性表

### 重点

1. 要求具有最优的性能（时间复杂度、空间复杂度）
2. 牢固掌握线性表的各种基本操作
3. 只能用c/c++语言实现

### 2.1 线性表的定义和基本操作

2.1.1 线性表的定义

线性表是具有相同数据类型的n(n>=0)个数据元素的有限序列。其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则一般表示为

```
L = (a1,a2,...,an);
```

- a1称为表头元素，an称为表尾元素
- 除了a1,表中每个元素都有一个唯一直接前驱元素，除了an，表中每个元素都有唯一一个直接后继元素

线性表的特点如下：

- 表中的元素个数有限
- 表中元素具有逻辑上的顺序性，表中元素有其先后次序
- 表中元素都是数据元素，每个元素都是单个元素
- 表中元素的数据类型相同，这以为着每个元素占有相同大小的存储空间
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟是什么内容。

注意：线性表逻辑结构。顺序表和链表都是存储结构

2.1.2 线性表的操作

操作如下（看书本）

### 2.2 线性表的顺序表示

2.2.1 顺序表的定义

线性表的顺序存储又称顺序表。他是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
   - 称i为元素ai在线性表中的位序
   - 顺序表的特点是表中的元素的逻辑顺序和物理顺序相同。

每个数据元素的存储位置都和线性表的其实位置想查一个和该数据元素的位序成正比的常数。因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储是一种随机存储结构

> 注：线性表中元素的位序是从1开始，而数组中元素的下标从0开始的。

线性表的顺序存储类型描述如下
```c
#define MaxSize 50 // 定义线性表的最大长度

typedef struct{
   ElemType data[MaxSize];  // 顺序表中的元素
   int length; // 顺序表当前的长度
}sqList; // 顺序表的类型定义
```

一维数组可以是静态分配的，也可以是动态分配的。

动态分配如下：
````c
#define InitSize 100; // 表长度初始定义

typedef struct {
   ElemType *data; // 只是动态分配数组的指针
   int MaxSize,length; // 数组最大容量和当前个数
}SeqList;   // 动态非配数组顺序表的类型定义
````
C语言初始动态分配语句如下：
```C
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
```

- 顺序表的最主要特点是随机访问。
- 顺序表的存储密度高，每个结点值存储数据元素
- 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除需要移动大量元素。